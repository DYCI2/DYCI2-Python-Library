; Créer les proc dans une map pour pouvoir les manipuler sans nombre prédéterminé !!!!!
; $proc := MAP{}
; $proc.insert (3, ::SetVoice())
; Faire de même pour les SequenceImpro et les memorys du coup ?
; $Impro_sequences := MAP{}
; $Impro_voices := MAP{}
; $Param_voices := MAP{}







$renderer := 1



$printimproinfo := 1
;==================================================================================================================
;==================================================================================================================
; BLOC 1: GLOBAL VARIABLES
; Scenario of the current improvisation (used for segmenting and labeling), symbolic "impro" sequences
; Modified using "setvar" in Max, ou via OSC, dynamically or not
;==================================================================================================================
;==================================================================================================================
$Xfadeduration := 40
$audio_latency_online := 423
$audio_latency_offline := 0


$pulsed := 0
$play := 0

;----------------------------------------------------------------------------------------
; INITIALISATION OF THE SEQUENCES (SCENARIOS, SYMBOLIC IMPRO SEQUENCES) RECEIVED FROM MAX
;----------------------------------------------------------------------------------------
$online_memory := MAP{}

$Scenario := MAP{}
$SequenceImpro := MAP{} ; Each musical event in the MAP : tab [idx to play in the memory, transposition]
$SequenceImpro1 := MAP{}
$SequenceImpro2 := MAP{}
$SequenceImpro3 := MAP{} 
$length_scenario := 0
$last_length_scenario := 0



whenever ($length_scenario)
{
	@local $cpt
	
	$last_length_scenario := $length_scenario

	$cpt := 0
	loop BuildSequences 0
		{
			;Test Jamatrix : commenter remplissge par défaut
			; Default impro sequence before receiving a generated sequence
			$SequenceImpro := @add_pair($SequenceImpro,$cpt, tab[($cpt - 4),0])
			$SequenceImpro1 := @add_pair($SequenceImpro1,$cpt, tab[($cpt - 4),0])
			$SequenceImpro2 := @add_pair($SequenceImpro2,$cpt, tab[($cpt - 4),0])
			$SequenceImpro3 := @add_pair($SequenceImpro3,$cpt, tab[($cpt - 4),0])

			; Default scenario before receiving a loaded scenario
			$Scenario := @add_pair($Scenario,$cpt, "label")

			$cpt := $cpt + 1
		} until ( $cpt >= $length_scenario)
 
	if ($printimproinfo) 
		{
			printAnte $renderer global "______Sequences built for the 1st time______"
			printAnte $renderer global "$Scenario :" $Scenario 
			printAnte $renderer global "$SequenceImpro :" $SequenceImpro
		}

}


;==================================================================================================================
;==================================================================================================================
; BLOC 2: TIME SOURCES AND OTHER TEMPORAL MECHANISMS
;==================================================================================================================
;==================================================================================================================

; Time source driving the whole program.
; !$pulsed --> internally modified
;  $pulsed --> coming from Max (metronome, beat tracker...)
$signal_new_position := -1

; Master position: tempo for memory annotation & segmentation
@tempovar $pos_in_scenario(120,1)
$tempovar_pos_in_scenario := 120
whenever ($tempovar_pos_in_scenario)
{
	let $pos_in_scenario.tempo := $tempovar_pos_in_scenario
	printAnte $renderer global "$pos_in_scenario.tempo = " ($pos_in_scenario.tempo)
}

$duration_current_master_event := 0
whenever ($duration_current_master_event == $duration_current_master_event)
{
	;printAnte $renderer global "(main)" "new $duration_current_master_event = " $duration_current_master_event ;"EQ TEMPO =" (60000/$duration_current_master_event) 
}
; POST MARTA 2
;whenever($pos_in_scenario == $pos_in_scenario)
;{
;	printAnte $renderer global "** (from max if nothing above) : $pos_in_scenario = " $pos_in_scenario "("($NOW*1000)")"
;}


; Local/slave position: tempo (if manual acceleration...)
@tempovar $pos_to_play(120,1)
$tempovar_pos_to_play := 120
whenever ($tempovar_pos_to_play)
{
	let $pos_to_play.tempo := $tempovar_pos_to_play
}

$mult_coeff_acc_tempo := 1
whenever ($mult_coeff_acc_tempo)
{
	let $pos_to_play.tempo := $mult_coeff_acc_tempo * ($pos_in_scenario.tempo)
	printAnte $renderer global "** FROM MAX : Mult. tempo $pos_to_play = " $mult_coeff_acc_tempo "("($NOW*1000)")"
}
whenever($pos_to_play == $pos_to_play)
{
	printAnte $renderer global "** FROM MAX : $pos_to_play = " $pos_to_play "("($NOW*1000)")"
}




;==================================================================================================================
;==================================================================================================================
; BLOC 3.1: DEFINITION OF THE FUNCTIONS CONTROLLING THE RENDERING OF AN EVENT
;==================================================================================================================
;==================================================================================================================
;ICI
@proc_def ::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, $position, $tempo, $activevoice, $audio_latency, $time_shift) 
	{

		@local $beatduration_in_memory, $speedratio
		@local $graincurvesduration_frac_beat, $graincurvesduration_in_memory, $Xfade_frac_beat, $Xfadeduration_in_memory, $date_end_Xfade_in_memory
		@local $voice, $output_audio
		@local $start_pos
		@local $date_process_SR, $pos_process_SR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_SR := ($NOW*1000)
		$pos_process_SR := $position

		printAnte $renderer $VoiceName "****"
		;printAnte $renderer $VoiceName "(SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")" ($NOW*1000)
		printAnte $renderer $VoiceName "[SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR "]" ($NOW*1000) "STARTING RENDERING POSITION " $position "(dates: " $date_start_segment_in_memory $date_end_segment_in_memory ")"
		;;printAnte $renderer $VoiceName $VoiceName "$TimeMaster = " $TimeMaster "$pulsed = " $pulsed "$tempo = " $tempo

		ControlRendering $renderer $VoiceName transpo $transpo 

		;Current beat durations values
		$beatduration_in_memory := ($date_end_segment_in_memory - $date_start_segment_in_memory)
		if ($TimeMaster)
		{
			if($pulsed)
				{
					printAnte $renderer global "(SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")" "$duration_current_master_event" $duration_current_master_event "-->" (60000/$tempo)
					$duration_current_master_event := 60000/$tempo
				}
			else {
					$duration_current_master_event := $beatduration_in_memory
					;printAnte $renderer global "(SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")" "$duration_current_master_event" $duration_current_master_event
				}
		}
		;faire un else pour temporalités multiples

		$speedratio := $beatduration_in_memory / $duration_current_master_event

		;Equivalent durations current tempo / tempo in the memory for Xfade
		$Xfade_frac_beat := ($Xfadeduration / $duration_current_master_event)
		$Xfadeduration_in_memory := (($Xfadeduration / $duration_current_master_event)*$beatduration_in_memory)
		$date_end_Xfade_in_memory := $date_end_segment_in_memory + $Xfadeduration_in_memory
		
		$voice := $activevoice		

		;9/11/17
		$start_pos := $date_start_segment_in_memory + $audio_latency - $time_shift
		if ($TimeMaster || ($speedratio >= 0.7  && $speedratio <= 1.3))
		{
			ControlRendering $renderer $VoiceName output_audio 1
			ControlRendering $renderer $VoiceName transpo $voice $transpo  
			;9/11/17
			;;;;;;;$start_pos := $date_start_segment_in_memory + $audio_latency - $time_shift
			ControlRendering $renderer $VoiceName beatScrubPos $voice $start_pos $speedratio ; new mode
			;REMETTRE CE PRINT !!
			;;printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, SENT TO PLAYER:" $voice $date_start_segment_in_memory $speedratio "beatduration:" $duration_current_master_event "nextbeatat?" (($NOW*1000)+$duration_current_master_event+$time_shift)
			;idx-in-memory-ratio $VoiceName $idx_start_play_in_memory_local $date_start_segment_in_memory $speedratio
		}
		else
		{
			::StopRendering($VoiceName, $TimeMaster, $pulsed, $position, $activevoice, $time_shift)
		}

		if (!$pulsed && $TimeMaster)
		{ 	

			$delay_trigger_next_event := ($duration_current_master_event+$time_shift)
			$next_event := (($position + 1) % $length_scenario)
			printAnte $renderer $VoiceName "(((SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION AT" ($delay_trigger_next_event+($NOW*1000)) "POSITION NOW = " $position
			;;printAnte $renderer global $VoiceName ($NOW*1000) " MASTER : ::StartRenderEvent will signal_new_position (now " $signal_new_position  ") in " ($duration_current_master_event+$time_shift) " ms ..."
			($delay_trigger_next_event)ms $signal_new_position := $next_event
			printAnte $renderer $VoiceName "[[[SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR "]]]" ($NOW*1000) "SIGNALED NEW POSITION AFTER SR = " $signal_new_position
			;;printAnte $renderer global $VoiceName "... " ($NOW*1000) " MASTER : ::StartRenderEvent : signal_new_position = " $signal_new_position
			;printAnte $renderer global "------------------------------------" 
			
		}
							
}


@proc_def ::UpdateSpeedRendering($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $position, $tempo, $activevoice) 
	{

		@local $beatduration_in_memory, $speedratio
		@local $graincurvesduration_frac_beat, $graincurvesduration_in_memory, $Xfade_frac_beat, $Xfadeduration_in_memory, $date_end_Xfade_in_memory
		@local $voice, $output_audio
		@local $start_pos
		@local $date_process_USR, $pos_process_USR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_USR := ($NOW*1000)
		$pos_process_USR := $position

		printAnte $renderer $VoiceName "****"
		;printAnte $renderer $VoiceName  "(USR" $VoiceName $date_process_USR ")"
		printAnte $renderer $VoiceName  "[USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR "]" "UPDATE SPEED RENDERING POSITION " $position "(dates: " $date_start_segment_in_memory $date_end_segment_in_memory ")"

		;ControlRendering $renderer $VoiceName transpo $transpo 

		;Current beat durations values
		$beatduration_in_memory := ($date_end_segment_in_memory - $date_start_segment_in_memory)
			if ($TimeMaster)
			{
				if($pulsed)
					{
						printAnte $renderer global "(USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR ")" "$duration_current_master_event" $duration_current_master_event "-->" (60000/$tempo)
						$duration_current_master_event := 60000/$tempo
					}
				else {
						$duration_current_master_event := $beatduration_in_memory
						;printAnte $renderer global "(USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR ")" "$duration_current_master_event" $duration_current_master_event

					}
			}
			;faire un else pour temporalités multiples

		$speedratio := $beatduration_in_memory / $duration_current_master_event

		;Equivalent durations current tempo / tempo in the memory for Xfade
		$Xfade_frac_beat := ($Xfadeduration / $duration_current_master_event)
		$Xfadeduration_in_memory := (($Xfadeduration / $duration_current_master_event)*$beatduration_in_memory)
		$date_end_Xfade_in_memory := $date_end_segment_in_memory + $Xfadeduration_in_memory
		
		$voice := $activevoice							
		;ControlRendering $renderer $VoiceName output_audio 1
		;ControlRendering $renderer $VoiceName transpo $voice $transpo  
		
		;$start_pos := $date_start_segment_in_memory + $audio_latency - $time_shift
		ControlRendering $renderer $VoiceName beatScrubPos $voice (-1) $speedratio ; new mode
		;REMETTRE CE PRINT
		;;printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, SENT TO PLAYER:" $voice "JUST change speed:" $speedratio  "nextbeatat?" (($NOW*1000)+$duration_current_master_event)
		;idx-in-memory-ratio $VoiceName $idx_start_play_in_memory_local $date_start_segment_in_memory $speedratio

		if (!$pulsed && $TimeMaster)
		{ 
			$delay_trigger_next_event := $duration_current_master_event
			$next_event := (($position + 1) % $length_scenario)
			printAnte $renderer global "(((USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION  AT" ($delay_trigger_next_event+($NOW*1000)) "NOW POSITION = " $position
 			;;printAnte $renderer global $VoiceName ($NOW*1000) " MASTER : ::UpdateSpeedRendering will signal_new_position (now " $signal_new_position ") in " ($duration_current_master_event) " ms ..."
			($delay_trigger_next_event)ms $signal_new_position := $next_event
			printAnte $renderer global "[[[USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR "]]]" ($NOW*1000) "SIGNALS NEW POSITION AFTER US = " $next_event
			;;printAnte $renderer global $VoiceName "... " ($NOW*1000) " MASTER : ::UpdateSpeedRendering : signal_new_position = " $signal_new_position
			;printAnte $renderer global "------------------------------------" 
			
			
		}
							
}


@proc_def ::StopRendering($VoiceName, $TimeMaster, $pulsed, $position, $activevoice, $time_shift) 
{
		@local $voice
		@local $date_process_StopR, $pos_process_StopR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_StopR := ($NOW*1000)
		$pos_process_StopR := $position
		
		$voice := $activevoice							
		ControlRendering $renderer $VoiceName beatScrubPos $voice (-1) 0 

		printAnte $renderer $VoiceName "****"
		printAnte $renderer $VoiceName "[StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR "]" ($NOW*1000)
		printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, STOPPED VOICEplayer:" $voice "(speed:" 0  ") nextbeatat?" (($NOW*1000)+$duration_current_master_event)

		if (!$pulsed && $TimeMaster)
		{ 
			$delay_trigger_next_event := $duration_current_master_event+$time_shift
			$next_event := (($position + 1) % $length_scenario)
			printAnte $renderer $VoiceName "(((StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION  AT" ($delay_trigger_next_event+($NOW*1000)) "POSITION NOW =" $signal_new_position $position
			($delay_trigger_next_event)ms $signal_new_position := $next_event
			printAnte $renderer global "[[[StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR "]]]" ($NOW*1000) "SIGNALS NEW POSITION AFTER STOP_R = " $signal_new_position $next_event

		}
							
}


;==================================================================================================================
;==================================================================================================================
; BLOC 3.2: DEFINITION OF THE GENERIC "VOICE" PROCESS
;==================================================================================================================
;==================================================================================================================
$pos_in_impro := -1

whenever ($pos_in_scenario == $pos_in_scenario)
{
	;printAnte $renderer global "(main)" ($NOW*1000) "$pos_in_scenario = " $pos_in_scenario ; "from max if nothing above)" 
	if (!$pulsed) ;; A CHANGER POUR MODULARISER LE whenever (new_date_seg_buf)
	{
		if ($first == 1 || $pos_in_scenario == 0) ; POST MARTA 2 : ||...
		{
			$pos_in_impro := $pos_in_scenario 
		} 
		else 
		{
			$pos_in_impro := $pos_in_impro + 1
		}
		$first := 0
		;idx-in-scenario-learning $renderer $pos_in_impro $pos_in_scenario $new_date_seg_buff
		pos_in_impro $renderer $pos_in_impro 
	}
}

@proc_def ::SetVoice($VoiceName, $InitSequenceImproOfVoice, $InitMemoryOfVoice, $TimeMaster) {

	@local $aux, $activevoice, $inactivevoice, $transpo, $start_Xfade, $old_idx_in_memory, $old_transpo
	@local $LoopBeat, $CurveBeat, $SequenceImproOfVoice, $MemoryOfVoice, $delay, $loop_count
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	@local $listened_variable
	@local $sync_variable, $synctempo
	@tempovar $sync_variable(120,1)
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	@local $play_pos
	@local $next_event_anticipated, $last_event_played, $start_rendering_launched_at_last_event
	
	$LoopBeat := 0


	$SequenceImproOfVoice := $InitSequenceImproOfVoice
	$MemoryOfVoice := $InitMemoryOfVoice
	$delay := $audio_latency_online


	whenever ($synctempo == $synctempo)
	{
		let $sync_variable.tempo := $synctempo
	}

	; MARTA
	$sync_variable := -1
	whenever ($sync_variable == $sync_variable && $sync_variable > -1)
	{
		;printAnte $renderer $VoiceName "(main" $VoiceName ")" ($NOW*1000) "new sync_variable = " $sync_variable 
	}



	$start_Xfade := 0
	$activevoice := 1
	$inactivevoice := 2

	whenever ($start_Xfade == 1)
	{
		;printAnte $renderer $VoiceName "(main" $VoiceName ")" " --------- DISC :" ($NOW*1000) " ---------"

		ControlRendering $renderer $VoiceName disc $activevoice 0.0
		ControlRendering $renderer $VoiceName disc $inactivevoice 1.0

		$aux := $activevoice 
		$activevoice := $inactivevoice
		$inactivevoice := $aux
	}
	ControlRendering $renderer $VoiceName output_audio 0

	$play_pos := -1 ;0
	$transpo := 0
	$last_event_played := 0
	$next_event_anticipated := 0
	$start_rendering_launched_at_last_event := 0
	$old_idx_in_memory := -1
	$old_transpo := -1



	;PROBLEME : ON NE PEUT PAS ECRIRE DANS LA VARIABLE GLOBALE CHOISIE !!!!
	$loop_count := 0
	whenever($listened_variable == $listened_variable) ;@exclusive
	{
		@local $relative_count_loop_whenever, $first_iteration_loop
		@local $date_process
		$date_process := ($NOW*1000)

		$relative_count_loop_whenever := 0
		$first_iteration_loop := 1

		if ($TimeMaster)
		{
			;printAnte $renderer global "------------------------------------" 
			;printAnte $renderer global "------------------------------------" 
			printAnte $renderer global "(list_var" $VoiceName $date_process ")" "TIME MASTER VOICE" $VoiceName ": RECEIVED LISTENED VAR = " $listened_variable "(signal_new_position)--> SENDS NEW POS_IN_SCENARIO"
			$pos_in_scenario := $listened_variable
			; DONC IL FAUT ABSOLUMENT QUE LA SYNC VARIABLE D'UNE VOIX MASTER SOIT POS IN SCENARIO !!!
			; SINON N'EST PAS UPDATE ICI !!
			printAnte $renderer global "(list_var" $VoiceName $date_process ")" "pos_in_scenario_by_sequencer = $pos_in_scenario sent to receiver max =" $pos_in_scenario
			pos_in_scenario_by_sequencer $renderer $pos_in_scenario
		}
		else
		{
			; ENLEVE POUR BURGER
			; REMIS POUR MARTA
			; $sync_variable := $listened_variable
		}


		if (!$pulsed)
		{
			;printAnte $renderer $VoiceName "(list_var" $VoiceName $date_process ")" "SYNC WHENEVER" "AT " ($NOW*1000) $pos_in_scenario "LISTENED VARIABLE UPDATED POS_IN_SCENARIO AND PLAY_POS"
			$play_pos := $pos_in_scenario 	
		}
		else
		{

			;printAnte $renderer $VoiceName "(list_var" $VoiceName $date_process ")" "SYNC WHENEVER" "AT " ($NOW*1000) $sync_variable "LISTENED VARIABLE UPDATED sync_variable"
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;printAnte $renderer global $VoiceName "LAPIN $relative_count_loop_whenever" $relative_count_loop_whenever
			$relative_count_loop_whenever := $relative_count_loop_whenever - 1
			$relative_count_loop_whenever := @max(0,$relative_count_loop_whenever)
			;printAnte $renderer $VoiceName "(list_var" $VoiceName $date_process ")" "SYNC WHENEVER" "$relative_count_loop_whenever" $relative_count_loop_whenever "..."

			if($relative_count_loop_whenever == 0)
			{

				;printAnte $renderer $VoiceName "(list_var" $VoiceName $date_process ")""SYNC WHENEVER" "... ABORTING LOOP" $loop_count "AND LAUNCHING NEW LOOP" ($loop_count+1)
				abort $LoopBeat
				$first_iteration_loop := 1

				$loop_count := $loop_count + 1
				$LoopBeat :=
				{
					@local $idloop
					@local $date_process_L
					$date_process_L := ($NOW*1000)
					$idloop := $loop_count
					loop 1 @sync $sync_variable @target[3s] @conservative
					@abort { printAnte $renderer $VoiceName $VoiceName "!!!!!!!!!!!!!!! ABORT LOOP " $idloop }
					{
						if ($first_iteration_loop)
						{
							printAnte $renderer $VoiceName "(list_var / loop" $date_process "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "AT " ($NOW*1000) $pos_in_scenario "PLAY POS FIRST ITERATION LOOP"
							printAnte $renderer $VoiceName "(list_var / loop" $date_process "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ":" "TEMPO sync_variable" ($sync_variable.tempo) " (associated duration:" (60000/($sync_variable.tempo)) " ms)"
							$play_pos := $sync_variable 
						}
						else
						{
							$relative_count_loop_whenever := $relative_count_loop_whenever + 1
							printAnte $renderer $VoiceName "(list_var / loop" $date_process "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "AT " ($NOW*1000) (($play_pos + 1) % $length_scenario) "PLAY POS UPDATED BY LOOP"
							printAnte $renderer $VoiceName "(list_var / loop" $date_process "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "TEMPO sync_variable" ($sync_variable.tempo) " (associated duration:" (60000/($sync_variable.tempo)) " ms)"
							printAnte $renderer $VoiceName "(list_var / loop" $date_process "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "Count loop / whenever :" $relative_count_loop_whenever 

							$play_pos := (($play_pos + 1) % $length_scenario)
						}
						$first_iteration_loop := 0
					}

				}
			}
			else
			{
				;;printAnte $renderer $VoiceName "SYNC WHENEVER" "LET LOOP " $idloop " RUNNING"
			}

		}

	}



	whenever ($play_pos == $play_pos)
	{

		@local $impro_segment
		@local $idx_to_play_in_memory
		@local $next_loop_idx, $next_impro_segment, $next_idx_to_play_in_memory, $next_transpo
		@local $jump_now, $jump_at_next_pos
		@local $start_segment_in_memory, $end_segment_in_memory, $testDEF, $date_start_segment_in_memory, $date_end_segment_in_memory
		@local $date_process, $pos_process
		$date_process := ($NOW*1000)
		$pos_process := $play_pos

				;15/11/17 ATTENTION CAR SI ON GENERE LOIN DU TEMPS DE RENDU, SAUTE QUAND MEME...
		whenever($SequenceImproOfVoice == $SequenceImproOfVoice && $play_pos > 1)
		{
			printAnte $renderer $VoiceName "MODIF IMPRO SEQUENCE !"
			;$last_event_played := 0
			$next_event_anticipated := 0
			;$start_rendering_launched_at_last_event := 0
			$impro_segment := $SequenceImproOfVoice($play_pos)
			$idx_to_play_in_memory := $impro_segment[0]
			$transpo := $impro_segment[1]
			; Retrieve the data to play at next position
			$next_impro_segment := $SequenceImproOfVoice(($play_pos+1) % $length_scenario) ;TODO MODULO POUR RETOURNER AU DEBUT
			$next_idx_to_play_in_memory := $next_impro_segment[0]
			$next_transpo := $next_impro_segment[1]
		
			; Update for next time
			$old_idx_in_memory := $idx_to_play_in_memory
			$old_transpo := $transpo
		}

		printAnte $renderer $VoiceName "========"
		;;printAnte $renderer $VoiceName $VoiceName "POSITION = " $play_pos ", LABEL = " ($Scenario($play_pos)) "(now = " ($NOW*1000) " ms)"
		printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "$pos_in_impro :" $pos_in_impro "/ $play_pos = " $play_pos ", $sync_variable = " $sync_variable ", tempo = " ($sync_variable.tempo) 
	
		; Retrieve the data to play at this position
		$impro_segment := $SequenceImproOfVoice($play_pos)
		$idx_to_play_in_memory := $impro_segment[0]
		$transpo := $impro_segment[1]
		; Retrieve the data to play at next position
		$next_impro_segment := $SequenceImproOfVoice(($play_pos+1) % $length_scenario) ;TODO MODULO POUR RETOURNER AU DEBUT
		$next_idx_to_play_in_memory := $next_impro_segment[0]
		$next_transpo := $next_impro_segment[1]
	
		; Update for next time
		$old_idx_in_memory := $idx_to_play_in_memory
		$old_transpo := $transpo


		

		printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "$impro_segment :" $impro_segment "$next_impro_segment :" $next_impro_segment
		printAnte $renderer $VoiceName "========"

		;---------------
		; CURRENT EVENT
		;---------------
		;;printAnte $renderer $VoiceName $VoiceName "------------- WORKING ON CURRENT EVENT"
		if (@is_undef($idx_to_play_in_memory)) ;;; IMPOSSIBLE TO PLAY CURRENT EVENT
		{	

			printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NOTHING NOW : Index to play in memory undefined"
			;LAST BURGER
			$start_Xfade := 1;LB
			::StopRendering($VoiceName, $TimeMaster, $pulsed, $play_pos, $activevoice, 0)
			($Xfadeduration/2) ControlRendering $renderer $VoiceName output_audio 0;DELAY LB
			$last_event_played := 0

		}
		else ;;; CURRENT EVENT IS DEFINED
		{
			idx_in_memory $VoiceName $idx_to_play_in_memory
			;;printAnte $renderer $VoiceName $VoiceName "PLAY WHENEVER"  "$idx_to_play_in_memory :" $idx_to_play_in_memory 
			;;printAnte $renderer $VoiceName $VoiceName "PLAY WHEN. NOW:"  "$impro_segment :" $impro_segment

			$jump_now := ($first || !$last_event_played || !$next_event_anticipated)
			printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "JUMP NOW: " $jump_now "<-- $first :" $first "!$last_event_played" (!$last_event_played) "!$next_event_anticipated" (!$next_event_anticipated)
			
			;ControlRendering $renderer $VoiceName transpo $transpo 
			$start_segment_in_memory := $MemoryOfVoice($idx_to_play_in_memory)
			$end_segment_in_memory := $MemoryOfVoice($idx_to_play_in_memory + 1)
			$testDEF := (!(@is_undef($start_segment_in_memory)) && !(@is_undef($end_segment_in_memory)))

			if($jump_now) ;;; DISCONTINUITY HANDLED NOW
			{
						
		
				if (!$testDEF )	
				{
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NOTHING NOW (undefined) [LAUNCH StopR *" $pos_process "*]"
					::StopRendering($VoiceName, $TimeMaster, $pulsed, $play_pos, $activevoice, 0)
					ControlRendering $renderer $VoiceName output_audio 0
					$last_event_played := 0
				} 
				else 
				{
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;printAnte $renderer global $VoiceName "LAPIN $end_segment_in_memory[0]" ($end_segment_in_memory[0])
					$date_start_segment_in_memory := $start_segment_in_memory[0]
					$date_end_segment_in_memory := $end_segment_in_memory[0] - 1
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" ($NOW*1000) "XFADE NOW & [LAUNCH SR *" $pos_process "*] dates = " $date_start_segment_in_memory $date_end_segment_in_memory
					$start_Xfade := 1
					::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, $play_pos, ($sync_variable.tempo), $activevoice, $delay, 0)
					$last_event_played := 1		
				}

			}; end "if($jump_now)"
			
			else ;;; CONTINUOUS NOW
			{
				; 8/11/17 (if)
				if ($start_rendering_launched_at_last_event == 1)
				{
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "CONTINUOUS NOW AND ANTICIPATED [nothing] "
					$last_event_played := 1
					
				}

				else
				{
					;printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "CONTINUOUS NOW"
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;printAnte $renderer global $VoiceName "LAPIN2 $end_segment_in_memory[0]" ($end_segment_in_memory[0])
					$date_start_segment_in_memory := $start_segment_in_memory[0]
					$date_end_segment_in_memory := $end_segment_in_memory[0] - 1
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "CONTINUOUS NOW [LAUNCH USR *" $pos_process "*] dates = " $date_start_segment_in_memory $date_end_segment_in_memory
					::UpdateSpeedRendering($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $play_pos, ($sync_variable.tempo), $activevoice)
					$last_event_played := 1

				}
			}

		};end "else @is_undef($idx_to_play_in_memory)""
	
		;---------------
		; NEXT EVENT
		;---------------
		;;printAnte $renderer $VoiceName $VoiceName "------------- WORKING ON NEXT EVENT"
		if (@is_undef($next_idx_to_play_in_memory)) ;;; NEXT EVENT : UNKNOWN
		{	

			;printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "NOTHING FOR NEXT EVENT : Index to play in memory undefined"
			$next_event_anticipated := 0
			$start_rendering_launched_at_last_event := 0

		}
		else ;;; NEXT EVENT IS DEFINED
		{
			;printAnte $renderer $VoiceName "CASE A $next_idx_to_play_in_memory :" $next_idx_to_play_in_memory
			printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "$next_idx_to_play_in_memory :" $next_idx_to_play_in_memory "$next_impro_segment :" $next_impro_segment
			
			// ;TEST CONTENU MEMOIRE
			// forall $k, $v in $MemoryOfVoice {
			// 	printAnte $renderer $VoiceName "MEMORYOFVOICE" $k $v
			// }


			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;printAnte $renderer global $VoiceName "LAPIN $next_idx_to_play_in_memory" $next_idx_to_play_in_memory
			$jump_at_next_pos := (@is_undef($idx_to_play_in_memory) || $idx_to_play_in_memory != ($next_idx_to_play_in_memory -1) || $transpo != $next_transpo)
			printAnte $renderer $VoiceName $VoiceName "PLAY WHEN. NEXT:"  "JUMP AT NEXT POSITION: " $jump_at_next_pos "<-- NOW IDX UNDEF / NEXT DEF :" (@is_undef($idx_to_play_in_memory)) " NON CONSECUTIVE :" ($idx_to_play_in_memory != ($next_idx_to_play_in_memory -1)) "TRANSPO CHANGE:" ($transpo != $next_transpo) 

			$start_segment_in_memory := $MemoryOfVoice($next_idx_to_play_in_memory)
			$end_segment_in_memory := $MemoryOfVoice($next_idx_to_play_in_memory + 1)
			$transpo := $next_transpo ;NEW 11 AVRIL 2017

			if($jump_at_next_pos) ;;; DISCONTINUITY HANDLED AT NEXT EVENT
			{
				;printAnte $renderer $VoiceName "CASE B"
				$testDEF := (!(@is_undef($start_segment_in_memory)) && !(@is_undef($end_segment_in_memory)))

				if (!$testDEF )	
				{
					;printAnte $renderer $VoiceName "CASE C $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "FINALLY NOTHING FOR NEXT EVENT : Segment in the memory at this index is undefined"
					$next_event_anticipated := 0
					$start_rendering_launched_at_last_event := 0
				} 
				else 
				{
					;printAnte $renderer $VoiceName "CASE D $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
					;printAnte $renderer global $VoiceName "LAPIN3 $end_segment_in_memory[0]" ($end_segment_in_memory[0])
					$date_start_segment_in_memory := $start_segment_in_memory[0]
					$date_end_segment_in_memory := $end_segment_in_memory[0] - 1
					$next_event_anticipated := 1
					$start_rendering_launched_at_last_event := 1
					;printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "NEXT XFADE in " ($duration_current_master_event - ($Xfadeduration/2)) "ms ... (at " (($NOW*1000) + ($duration_current_master_event - ($Xfadeduration/2))) ")"
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" ($NOW*1000) "(next) WILL XFADE & [WILL LAUNCH SR *" ($pos_process+1) "*] at " (($NOW*1000) + ($duration_current_master_event - ($Xfadeduration/2))) "/ dates = " $date_start_segment_in_memory $date_end_segment_in_memory
					($duration_current_master_event - ($Xfadeduration/2))ms group {
																					$start_Xfade := 1
																					;::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, ($play_pos + 1), ($sync_variable.tempo), $activevoice, $delay, ($Xfadeduration/2))		
																					::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, ($pos_process + 1), ($sync_variable.tempo), $activevoice, $delay, ($Xfadeduration/2))		
																			}
					
					
				}

			}; end "if($jump_at_next_pos)"
			
			else ;;; CONTINUOUS AT NEXT EVENT
			{
				;printAnte $renderer $VoiceName "CASE E $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
				;BURGER FINALE
				;printAnte $renderer global $VoiceName "LAPIN4 $end_segment_in_memory[0]" ($end_segment_in_memory[0])
				$date_start_segment_in_memory := $start_segment_in_memory[0]
				$date_end_segment_in_memory := ($end_segment_in_memory[0] - 1)
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NEXT EVENT CONTINUOUS dates: (beg $start_segment" $start_segment_in_memory " =)"  $date_start_segment_in_memory "(beg $end_segment" $end_segment_in_memory " -1 =)" $date_end_segment_in_memory
				; 8/11/17
				$next_event_anticipated := 1
				;$next_event_anticipated := 0
				$start_rendering_launched_at_last_event := 0
			}

		};end "else @is_undef($next_idx_to_play_in_memory)"
	}
}


				


;==================================================================================================================
;==================================================================================================================
; BLOC 4: HANDLING START / STOP IMPRO
; INITIALISATION OF THE VOICES
;==================================================================================================================
;==================================================================================================================
whenever ($play == 1)
{ 
	@local $cpt

	printAnte $renderer global "_________PLAY : ON_________"

if ($last_length_scenario !=0) {
	$Scenario := MAP{}
	$SequenceImpro1 := MAP{}
	$SequenceImpro2 := MAP{}
	$SequenceImpro3 := MAP{} ; Each musical slice in the MAP : tab [idx to play in the memory, transposition]
	;$length_scenario := $length_scenario	

	$cpt := 0
	loop BuildSequences 0
		{
			; Default "impro"
			$SequenceImpro1 := @add_pair($SequenceImpro1,$cpt, tab[($cpt - 4),0])
			$SequenceImpro2 := @add_pair($SequenceImpro2,$cpt, tab[($cpt - 4),0])
			$SequenceImpro3 := @add_pair($SequenceImpro3,$cpt, tab[($cpt - 4),0])
			; Default scenario
			$Scenario := @add_pair($Scenario,$cpt, "label")

			$cpt := $cpt + 1
		} until ( $cpt >= $last_length_scenario)
	if ($printimproinfo) 
		{
			printAnte $renderer global "______Default sequences built again______"
			printAnte $renderer global "$Scenario :" $Scenario 
			printAnte $renderer global "$SequenceImpro :" $SequenceImpro
		}
	}


	;::SetVoice($VoiceName, $InitSequenceImproOfVoice, $InitMemoryOfVoice, $TimeMaster)
	$name_currentVoice1 := "Voice" + $renderer
	$currentVoice1 := ::SetVoice($name_currentVoice1, $SequenceImpro1, $online_memory, 1)
	;Synchronizing Voice 1 with the temporal variable "$pos_in_scenario"
	whenever($signal_new_position == $signal_new_position)
	{
		printAnte $renderer global "(main/signal_new_pos)" ($NOW*1000) "Voice1 --> LISTENED_VARIABLE (sig...)=" $signal_new_position
		$currentVoice1.$listened_variable := $signal_new_position
		;;printAnte $renderer global "Voice1 --> LISTENED_VARIABLE TOOK NEW VALUE OF signal_new_position" $signal_new_position
	}
	whenever($pos_in_scenario == $pos_in_scenario )
	{
		$currentVoice1.$sync_variable := $pos_in_scenario
	}
	whenever ($tempovar_pos_in_scenario)
	{
		let $currentVoice1.$synctempo := $tempovar_pos_in_scenario
	}	
	$currentVoice1.$delay := $audio_latency_online


	; COMMENTE POUR TESTS MARTA
	/* $currentVoice2 := ::SetVoice("Voice2", $SequenceImpro2, $online_memory, 0)
	;;Synchronizing Voice 2 with the temporal variable "$pos_to_play"
	whenever($pos_in_scenario == $pos_in_scenario)
	{
		$currentVoice2.$listened_variable := $pos_in_scenario
	}
	whenever($pos_to_play == $pos_to_play)
	{
		$currentVoice2.$sync_variable := $pos_to_play
	}
	whenever ($tempovar_pos_to_play)
	{
		let $currentVoice2.$synctempo := $tempovar_pos_to_play
	}
	$currentVoice2.$delay := $audio_latency_online


	$currentVoice3 := ::SetVoice("Voice3", $SequenceImpro3, $online_memory, 0) 
	;Synchronizing Voice 3 with the temporal variable "$pos_to_play"
	whenever($pos_in_scenario == $pos_in_scenario)
	{
		$currentVoice3.$listened_variable := $pos_in_scenario
	}
	whenever($pos_to_play == $pos_to_play)
	{
		$currentVoice3.$sync_variable := $pos_to_play
	}
	whenever ($tempovar_pos_to_play)
	{
		let $currentVoice3.$synctempo := $tempovar_pos_to_play
	}
	$currentVoice3.$delay := $audio_latency_online */

	if ($printimproinfo) 
		{
			printAnte $renderer global "______Processes launched______"
			printAnte $renderer global "$Scenario :" $Scenario 
			printAnte $renderer global "$SequenceImpro :" $SequenceImpro
		}

}

whenever ($play == 0)
{ 

	printAnte $renderer global "_________PLAY : OFF_________"


	ControlRendering $renderer "Voice1" output_audio 0
	ControlRendering $renderer "Voice2" output_audio 0
	ControlRendering $renderer "Voice3" output_audio 0
	
	abort $currentVoice1
	;COMMENTE POUR TESTS MARTA
	;abort $currentVoice2
	;abort $currentVoice3


	if ($printimproinfo) 
		{
			printAnte $renderer global "______Processes aborted______"
		}


}



$date_beginning_buffer := -1
whenever ($startrecordbuffer)
{
	$date_beginning_buffer := $NOW

}

;------------------------------------------------------------------
; ONLINE SEGMENTATION OF THE INPUTS (AUDIO OR NOT...)
;----------------------
; segmented_memory  
; key -> data :
; position in impro -> [date in the buffer, label, position in the scenario]
;----------------------
$first := 1
$new_date_seg_buff := -1
$pos_in_scenario := -1
$pos_to_play := 0
;---

whenever ($new_posinscenario_datesegbuff)
{
	
	if ($pulsed)
	{
		;-VERSIONSANSTRANSPORT
		if ($date_beginning_buffer > -1) {
			$new_date_seg_buff := ($NOW - $date_beginning_buffer)*1000
		} else {
			$new_date_seg_buff := -1
		}

		$new_pos_in_scenario := $new_posinscenario_datesegbuff[0]
		printAnte $renderer Voice1 "\n\n\n"
		printAnte $renderer Voice1 "\n\n\n"
		printAnte $renderer global Voice1 " --------- NEW POS SIGNALED BY BANG" $new_pos_in_scenario " ---------" ($NOW*1000)
		printAnte $renderer global " --------- NEW POS SIGNALED LAUNCHED BY BANG" $new_pos_in_scenario " ---------" ($NOW*1000) 

		;;;;;;;;;;;;;;;;;  30/01/17 : "pos_in_scenario remplacé par $signal_new_position"
		

		
		if ($first == 1) {
			$pos_in_impro := $new_pos_in_scenario 
			abs_rec_start $new_date_seg_buff ; gn 160607
		} else {
			$pos_in_impro := $pos_in_impro + 1
		}

		$signal_new_position := $new_pos_in_scenario
		printAnte $renderer global "datesegbuff --> pos_in_scenario_by_sequencer = $signal_new_position sent to receiver max =" $signal_new_position
		pos_in_scenario_by_sequencer $renderer $signal_new_position
		idx-in-scenario-learning $renderer $signal_new_position

		$first := 0
		idx-in-scenario-learning $renderer $pos_in_impro $pos_in_scenario $new_date_seg_buff
		pos_in_impro $renderer $pos_in_impro 

		
		/*Convention : tab [posinscenario, datesegbuff], 
		with datesegbuff = -1 when offline (no online buffer to segment)*/
		if ($new_date_seg_buff > -1) {
			;$label_new_pos := $Scenario[$new_pos_in_scenario]
			$label_new_pos := $Scenario($new_pos_in_scenario)
		
			$new_segment := tab[$new_date_seg_buff, $label_new_pos, $new_pos_in_scenario]

			$online_memory := @add_pair($online_memory,$pos_in_impro,$new_segment)
			
			printAnte $renderer global "RECORDING SEGMENT [" $new_segment "]  POUR POS_IN_IMPRO " $pos_in_impro
		}
	}
	
}





;==================================================================================================================
;==================================================================================================================
; BLOC 5: HANDLING MEMORY (LOAD AND SAVE)
;==================================================================================================================
;==================================================================================================================
@proc_def SendMap($m, $slot, $idxInTab)
{
	$i := 0
	$s := ""
	forall $k, $v in $m 
	{	
		if ($idxInTab > -1) 
		{
			if ($idxInTab == 1) 
			{
				$s:= $s+(" "+"\""+($v[$idxInTab])+"\"")
			} 
			else 
			{
				$s:= $s+(" "+($v[$idxInTab]))
			}
		} 
		else 
		{
			$s:= $s+(" "+($v))
		}
	
		AnteToSave $renderer (""+$slot) $s
	}
}

whenever ($save_annotations)
{
	::SendMap($online_memory,"labels",1)
	::SendMap($online_memory,"dates",0)
	::SendMap($online_memory,"pos_in_scenario",2)	
	AnteToSave $renderer "last_temposession" $tempovar_pos_to_play
	$play := 0
}

;LOAD MEMORY 1
;==================================================================================================================
$cpt_load_memory_Voice1 := 0
;$next_pos_to_load_in_memory_Voice1 := 0

whenever ($cpt_load_memory_Voice1 == $cpt_load_memory_Voice1)
{
	// printAnte $renderer Voice1 "!!!!!!!!!!!!!!!!!!!!!! $cpt_load_memory_Voice1 !!!!!!!!!!!!!!!!!!!!!! " $cpt_load_memory_Voice1

}


$start_pos_load_Voice1 := 0
whenever ($start_pos_load_Voice1 == $start_pos_load_Voice1)
{
	// printAnte $renderer Voice1
	// printAnte $renderer Voice1
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $start_pos_load_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	// printAnte $renderer Voice1 "LOADED $start_pos_load Voice1" $start_pos_load_Voice1
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $start_pos_load_Voice1 //////////////////// " $cpt_load_memory_Voice1
	
}

$load_pos_in_scenario_Voice1 := tab[]
whenever ($load_pos_in_scenario_Voice1)
{
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_pos_in_scenario_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	// printAnte $renderer Voice1 "LOADED $load_pos_in_scenario Voice1" 
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_pos_in_scenario_Voice1 //////////////////// " $cpt_load_memory_Voice1
	// ;TEST TAILLE MESSAGES
	// forall $p in $load_pos_in_scenario_Voice1{
	// 	printAnte $renderer Voice1  $p
	// }
	
}

$load_labels_Voice1 := tab[]
whenever ($load_labels_Voice1)
{
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_labels_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	// printAnte $renderer Voice1  "LOADED $load_labels Voice1"
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_labels_Voice1 //////////////////// " $cpt_load_memory_Voice1
	// ;TEST TAILLE MESSAGES
	// forall $p in $load_labels_Voice1{
	// 	printAnte $renderer Voice1  $p
	// }
}

$load_dates_Voice1 := tab[]
whenever ($load_dates_Voice1)
{
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_dates_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	// printAnte $renderer Voice1  "LOADED $load_dates Voice1"
	// printAnte $renderer Voice1 "//////////////////// $cpt_load_memory_Voice1 $load_dates_Voice1 //////////////////// " $cpt_load_memory_Voice1
	// ;TEST TAILLE MESSAGES
	// forall $p in $load_dates_Voice1{
	// 	printAnte $renderer Voice1  $p
	// }
}

whenever ($cpt_load_memory_Voice1 == 4)
{
	@local $posi, $p
	
	$loaded_memory_Voice1 := MAP{}

	$currentVoice1.$delay := $audio_latency_offline

	;$posi := $next_pos_to_load_in_memory_Voice1
	$posi := $start_pos_load_Voice1
	// printAnte $renderer Voice1 "***** $posi *****" $posi
	// printAnte $renderer Voice1 "***** $posi *****" $posi
	// printAnte $renderer Voice1 "***** $posi *****" $posi
	// printAnte $renderer Voice1 "***** $posi *****" $posi
	// printAnte $renderer Voice1 "***** $posi *****" $posi

	printAnte $renderer Voice1 "***** $start_pos_load_Voice1 *****" $start_pos_load_Voice1
	// printAnte $renderer Voice1 "***** $load_pos_in_scenario_Voice1 *****" $load_pos_in_scenario_Voice1
	// printAnte $renderer Voice1 "***** $load_labels_Voice1 *****" $load_labels_Voice1
	// printAnte $renderer Voice1 "***** $$load_dates_Voice1 *****" $load_dates_Voice1


	forall $p in $load_pos_in_scenario_Voice1
	{
		;$loaded_memory_segment_Voice1 := tab[($load_dates_Voice1[($posi - $next_pos_to_load_in_memory_Voice1)]), ($load_labels_Voice1[($posi - $next_pos_to_load_in_memory_Voice1)]), $p]
		$loaded_memory_segment_Voice1 := tab[($load_dates_Voice1[($posi - $start_pos_load_Voice1)]), ($load_labels_Voice1[($posi - $start_pos_load_Voice1)]), $p]
		;$loaded_memory_Voice1 := @add_pair($loaded_memory_Voice1,$posi,$loaded_memory_segment_Voice1)
		$currentVoice1.$MemoryOfVoice := @add_pair($currentVoice1.$MemoryOfVoice,$posi,$loaded_memory_segment_Voice1)
		$posi := $posi + 1
	}
	// printAnte $renderer Voice1 "------ $posi ------" $posi
	// printAnte $renderer Voice1 "------ $posi ------" $posi
	// printAnte $renderer Voice1 "------ $posi ------" $posi
	// printAnte $renderer Voice1 "------ $posi ------" $posi
	// printAnte $renderer Voice1 "------ $posi ------" $posi

	;$next_pos_to_load_in_memory_Voice1 := $posi
	;$next_pos_to_load_in_memory_Voice1 := 0

	;$currentVoice1.$MemoryOfVoice := $loaded_memory_Voice1
		
	$cpt_load_memory_Voice1 := 0

	printAnte $renderer Voice1 "*****MEMORY Voice1 LOADED*****" ($currentVoice1.$MemoryOfVoice)
	// ;TEST CONTENU MEMOIRE
	// 		forall $k, $v in $currentVoice1.$MemoryOfVoice {
	// 			printAnte $renderer Voice1 "MEMORYOFVOICE" $k $v
	// 		}

}
;LOAD MEMORY 2
;==================================================================================================================
$cpt_load_memory_Voice2 := 0
$next_pos_to_load_in_memory_Voice2 := 0
$load_pos_in_scenario_Voice2 := tab[]
whenever ($load_pos_in_scenario_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
	printAnte $renderer Voice2 "LOADED $load_pos_in_scenario Voice2"
	
}
$load_labels_Voice2 := tab[]
whenever ($load_labels_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
	printAnte $renderer Voice2 "LOADED $load_labels Voice2"
}

$load_dates_Voice2 := tab[]
whenever ($load_dates_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
	printAnte $renderer Voice2 "LOADED $load_dates Voice2"
}
whenever ($cpt_load_memory_Voice2 == 3)
{
	@local $posi, $p
	
	$loaded_memory_Voice2 := MAP{}
	
	$currentVoice2.$delay := $audio_latency_offline ;TRIIIICK : mettre online

	$posi := $next_pos_to_load_in_memory_Voice2
	forall $p in $load_pos_in_scenario_Voice2
	{
		$loaded_memory_segment_Voice2 := tab[($load_dates_Voice2[($posi - $next_pos_to_load_in_memory_Voice2)]), ($load_labels_Voice2[($posi - $next_pos_to_load_in_memory_Voice2)]), $p]
		$loaded_memory_Voice2 := @add_pair($loaded_memory_Voice2,$posi,$loaded_memory_segment_Voice2)
		$posi := $posi + 1
	}

	;$next_pos_to_load_in_memory_Voice2 := $posi
	$next_pos_to_load_in_memory_Voice2 := 0

	$currentVoice2.$MemoryOfVoice := $loaded_memory_Voice2
		
	$cpt_load_memory_Voice2 := 0

	printAnte $renderer Voice2 "MEMORY Voice2 LOADED" ($currentVoice2.$MemoryOfVoice)

}
;LOAD MEMORY 3
;==================================================================================================================
$cpt_load_memory_Voice3 := 0
$next_pos_to_load_in_memory_Voice3 := 0

$load_pos_in_scenario_Voice3 := tab[]
whenever ($load_pos_in_scenario_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
	printAnte $renderer Voice3 "LOADED $load_pos_in_scenario Voice3"
	
}
$load_labels_Voice3 := tab[]
whenever ($load_labels_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
	printAnte $renderer Voice3 "LOADED $load_labels Voice3"
}

$load_dates_Voice3 := tab[]
whenever ($load_dates_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
	printAnte $renderer Voice3 "LOADED $load_dates Voice3"
}
whenever ($cpt_load_memory_Voice3 == 3)
{
	@local $posi, $p
	
	$loaded_memory_Voice3 := MAP{}

	$currentVoice3.$delay := $audio_latency_offline;TRIIIICK : mettre online

	$posi := $next_pos_to_load_in_memory_Voice3
	forall $p in $load_pos_in_scenario_Voice3
	{
		$loaded_memory_segment_Voice3 := tab[($load_dates_Voice3[($posi - $next_pos_to_load_in_memory_Voice3)]), ($load_labels_Voice3[($posi - $next_pos_to_load_in_memory_Voice3)]), $p]
		$loaded_memory_Voice3 := @add_pair($loaded_memory_Voice3,$posi,$loaded_memory_segment_Voice3)
		$posi := $posi + 1
	}

	;$next_pos_to_load_in_memory_Voice3 := $posi
	$next_pos_to_load_in_memory_Voice3 := 0

	$currentVoice3.$MemoryOfVoice := $loaded_memory_Voice3
		
	$cpt_load_memory_Voice3 := 0

	printAnte $renderer Voice3 "MEMORY Voice3 LOADED" ($currentVoice3.$MemoryOfVoice)

}






;==================================================================================================================
;==================================================================================================================
; BLOC 6: HANDLING SCENARIOS AND IMPROS (SAVE AND LOAD)
;==================================================================================================================
;==================================================================================================================
whenever ($ModifScenario0)
{

printAnte $renderer global "PREVIOUS SCENARIO :" $Scenario

	forall $k, $v in $ModifScenario0 {
			$Scenario := @add_pair($Scenario,$k, $v)
		
	}

printAnte $renderer global "NEW SCENARIO :" $Scenario

}
whenever ($ModifSequenceImproOfVoice1)
{

printAnte $renderer Voice1 "VOICE 1 : PREVIOUS IMPRO :" $currentVoice1.$SequenceImproOfVoice

	forall $k, $v in $ModifSequenceImproOfVoice1 {
			$currentVoice1.$SequenceImproOfVoice := @add_pair(($currentVoice1.$SequenceImproOfVoice),$k, $v)
		
	}

printAnte $renderer Voice1 "VOICE 1 : NEW IMPRO :" $currentVoice1.$SequenceImproOfVoice

}
whenever ($ModifSequenceImproOfVoice2)
{

printAnte $renderer Voice2 "VOICE 2 : PREVIOUS IMPRO :" $currentVoice2.$SequenceImproOfVoice

	forall $k, $v in $ModifSequenceImproOfVoice2 {
			$currentVoice2.$SequenceImproOfVoice := @add_pair(($currentVoice2.$SequenceImproOfVoice),$k, $v)
		
	}

printAnte $renderer Voice2 "VOICE 2 : NEW IMPRO :" $currentVoice2.$SequenceImproOfVoice

}
whenever ($ModifSequenceImproOfVoice3)
{

printAnte $renderer Voice3 "VOICE 3 : PREVIOUS IMPRO :" $currentVoice3.$SequenceImproOfVoice

	forall $k, $v in $ModifSequenceImproOfVoice3 {
			$currentVoice3.$SequenceImproOfVoice := @add_pair(($currentVoice3.$SequenceImproOfVoice),$k, $v)
		
	}

printAnte $renderer Voice3 "VOICE 3 : NEW IMPRO :" $currentVoice3.$SequenceImproOfVoice
}