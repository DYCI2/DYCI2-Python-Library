; Créer les proc dans une map pour pouvoir les manipuler sans fixer de nombre de voix !
; $proc := MAP{}
; $proc.insert (3, ::SetVoice())
; Faire de même pour les SequenceImpro et les memorys du coup ?
; $Impro_sequences := MAP{}
; $Impro_voices := MAP{}
; $Param_voices := MAP{}

antescofo::suivi 0

$renderer := 1
$printimproinfo := false ; true
;==================================================================================================================
;==================================================================================================================
; BLOC 1: GLOBAL VARIABLES
; Scenario of the current improvisation (used for segmenting and labeling), symbolic "impro" sequences
; Modified using "setvar" in Max, ou via OSC, dynamically or not
;==================================================================================================================
;==================================================================================================================
$Xfadeduration := 40
$audio_latency_online := 423
$audio_latency_offline := 0

$pulsed := 0
$play := 0

;----------------------------------------------------------------------------------------
; INITIALISATION OF THE SEQUENCES (SCENARIOS, SYMBOLIC IMPRO SEQUENCES) RECEIVED FROM MAX
;----------------------------------------------------------------------------------------
$online_memory := MAP{}
$memory1 := MAP{}
$memory2 := MAP{}
$memory3 := MAP{}
$memory4 := MAP{}

$Scenario := MAP{}
$SequenceImpro := MAP{} ; Each musical event in the MAP : tab [idx to play in the memory, transposition]
$SequenceImpro1 := MAP{}
$SequenceImpro2 := MAP{}
$SequenceImpro3 := MAP{} 
$SequenceImpro4 := MAP{} 
$length_scenario := 0
$last_length_scenario := 0



whenever W1 ($length_scenario)
{
	@local $cpt
	
	$last_length_scenario := $length_scenario

	$cpt := 0
	loop BuildSequences 0
		{
			; Default impro sequence before receiving a generated sequence
			$SequenceImpro := @add_pair($SequenceImpro,$cpt, tab[($cpt - 4),0])
			$SequenceImpro1 := @add_pair($SequenceImpro1,$cpt, tab[($cpt - 4),0])
			$SequenceImpro2 := @add_pair($SequenceImpro2,$cpt, tab[($cpt - 4),0])
			$SequenceImpro3 := @add_pair($SequenceImpro3,$cpt, tab[($cpt - 4),0])
			$SequenceImpro4 := @add_pair($SequenceImpro3,$cpt, tab[($cpt - 4),0])
			; Default scenario before receiving a loaded scenario
			$Scenario := @add_pair($Scenario,$cpt, "label")

			$cpt := $cpt + 1
		} until ( $cpt >= $length_scenario)
 
	if ($printimproinfo) 
		{
			printAnte $renderer global "______Sequences built for the 1st time______"
			printAnte $renderer global "$Scenario :" ("" + $Scenario)
			printAnte $renderer global "$SequenceImpro :" $SequenceImpro
		}

}


;==================================================================================================================
;==================================================================================================================
; BLOC 2: TIME SOURCES AND OTHER TEMPORAL MECHANISMS
;==================================================================================================================
;==================================================================================================================

; Time source driving the whole program.
; !$pulsed --> internally modified
;  $pulsed --> coming from Max (metronome, beat tracker...)
$signal_new_position := -1

; Master position: tempo for memory annotation & segmentation
@tempovar $pos_in_scenario(120,1)
$tempovar_pos_in_scenario := 120
whenever ($tempovar_pos_in_scenario)
{
	let $pos_in_scenario.tempo := $tempovar_pos_in_scenario
	if ($printimproinfo) 
		{
			printAnte $renderer global "$pos_in_scenario.tempo = " ($pos_in_scenario.tempo)
		}
}

$duration_current_master_event := 0
whenever ($duration_current_master_event == $duration_current_master_event && $duration_current_master_event > 0 && $printimproinfo)
{
	printAnte $renderer global "(main)" "new $duration_current_master_event = " $duration_current_master_event ;"EQ TEMPO =" (60000/$duration_current_master_event) 
}

; Local/slave position: tempo (if manual acceleration...)
@tempovar $pos_to_play(120,1)
$tempovar_pos_to_play := 120
whenever ($tempovar_pos_to_play)
{
	let $pos_to_play.tempo := $tempovar_pos_to_play
}

$mult_coeff_acc_tempo := 1
whenever ($mult_coeff_acc_tempo)
{
	let $pos_to_play.tempo := $mult_coeff_acc_tempo * ($pos_in_scenario.tempo)
	if ($printimproinfo) 
		{
			printAnte $renderer global "** FROM MAX : Mult. tempo $pos_to_play = " $mult_coeff_acc_tempo "("($NOW*1000)")"
		}
}
whenever($pos_to_play == $pos_to_play)
{
	if ($printimproinfo) 
		{
			printAnte $renderer global "** FROM MAX : $pos_to_play = " $pos_to_play "("($NOW*1000)")"
		}
}




;==================================================================================================================
;==================================================================================================================
; BLOC 3.1: DEFINITION OF THE FUNCTIONS CONTROLLING THE RENDERING OF AN EVENT
;==================================================================================================================
;==================================================================================================================
$nb_renderer := 0

@proc_def ::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, $position, $tempo, $activevoice, $audio_latency, $time_shift) 
{
	    $nb_renderer := 1 + $nb_renderer
		if ($nb_renderer > 0)
		{ printAnte $renderer $VoiceName "Tuilage avec ::StartRenderEvent" $nb_renderer }

		@local $beatduration_in_memory, $speedratio
		@local $graincurvesduration_frac_beat, $graincurvesduration_in_memory, $Xfade_frac_beat, $Xfadeduration_in_memory, $date_end_Xfade_in_memory
		@local $voice, $output_audio
		@local $start_pos
		@local $date_process_SR, $pos_process_SR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_SR := ($NOW*1000)
		$pos_process_SR := $position

		if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName "[SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR "]" ($NOW*1000) "STARTING RENDERING POSITION " $position "(dates: " $date_start_segment_in_memory $date_end_segment_in_memory ")"
			}

		ControlRendering $renderer $VoiceName transpo $transpo 

		;Current beat durations values
		$beatduration_in_memory := ($date_end_segment_in_memory - $date_start_segment_in_memory)
		if ($TimeMaster)
		{
			if($pulsed && $tempo >0)
				{
					printAnte $renderer global "(SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")" "$duration_current_master_event" $duration_current_master_event "-->" (60000/$tempo)
					$duration_current_master_event := 60000/$tempo
				}
			else {
					$duration_current_master_event := $beatduration_in_memory
				}
		}
		;TODO: else multiple temporalities
		
		$duration_current_master_event := ($duration_current_master_event == 0 ? 1 :  $duration_current_master_event)
		$speedratio := $beatduration_in_memory / $duration_current_master_event

		;Equivalent durations current tempo / tempo in the memory for Xfade
		$Xfade_frac_beat := ($Xfadeduration / $duration_current_master_event)
		$Xfadeduration_in_memory := (($Xfadeduration / $duration_current_master_event)*$beatduration_in_memory)
		$date_end_Xfade_in_memory := $date_end_segment_in_memory + $Xfadeduration_in_memory
		
		$voice := $activevoice		

		$start_pos := $date_start_segment_in_memory + $audio_latency - $time_shift
		if (1>0);($TimeMaster || ($speedratio >= 0.6  && $speedratio <= 1.5)) ;
		{
			ControlRendering $renderer $VoiceName output_audio 1
			ControlRendering $renderer $VoiceName transpo $voice $transpo  
			ControlRendering $renderer $VoiceName beatScrubPos $voice $start_pos $speedratio
			;printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, SENT TO PLAYER:" $voice $date_start_segment_in_memory $speedratio "beatduration:" $duration_current_master_event "nextbeatat?" (($NOW*1000)+$duration_current_master_event+$time_shift)
			;For video applications
			;idx-in-memory-ratio $VoiceName $idx_start_play_in_memory_local $date_start_segment_in_memory $speedratio
		}
		else
		{
			::StopRendering($VoiceName, $TimeMaster, $pulsed, $position, $voice, $time_shift)
		}

		if (!$pulsed && $TimeMaster)
		{ 	
			$delay_trigger_next_event := ($duration_current_master_event+$time_shift)
			$next_event := (($position + 1) % $length_scenario)
			if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName "(((SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION AT" ($delay_trigger_next_event+($NOW*1000)) "POSITION NOW = " $position
			}

			($delay_trigger_next_event)ms $signal_new_position := $next_event
			$nb_renderer := $nb_renderer - 1

			if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName "[[[SR" $VoiceName " *" $pos_process_SR "* " $date_process_SR "]]]" ($NOW*1000) "SIGNALED NEW POSITION AFTER SR = " $signal_new_position
			}
		}
		else { $nb_renderer := $nb_renderer - 1 }
							
}


@proc_def ::UpdateSpeedRendering($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $position, $tempo, $activevoice) 
	{
		$nb_renderer := 1 + $nb_renderer
		if ($nb_renderer > 0)
		{ printAnte $renderer $VoiceName "Tuilage avec ::UpdateSpeedRendering" $nb_renderer }


		@local $beatduration_in_memory, $speedratio
		@local $graincurvesduration_frac_beat, $graincurvesduration_in_memory, $Xfade_frac_beat, $Xfadeduration_in_memory, $date_end_Xfade_in_memory
		@local $voice, $output_audio
		@local $start_pos
		@local $date_process_USR, $pos_process_USR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_USR := ($NOW*1000)
		$pos_process_USR := $position

		if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName  "[USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR "]" "UPDATE SPEED RENDERING POSITION " $position "(dates: " $date_start_segment_in_memory $date_end_segment_in_memory ")"
			}

		;Current beat durations values
		$beatduration_in_memory := ($date_end_segment_in_memory - $date_start_segment_in_memory)
			if ($TimeMaster)
			{
				if($pulsed)
					{
						if ($printimproinfo) 
							{
								printAnte $renderer global "(USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR ")" "$duration_current_master_event" $duration_current_master_event "-->" (60000/$tempo)
							}

						$duration_current_master_event := 60000/$tempo
					}
				else {
						$duration_current_master_event := $beatduration_in_memory
					}
			}
			;TODO: else for multiple temporalities

		$speedratio := $beatduration_in_memory / $duration_current_master_event

		;Equivalent durations current tempo / tempo in the memory for Xfade
		$Xfade_frac_beat := ($Xfadeduration / $duration_current_master_event)
		$Xfadeduration_in_memory := (($Xfadeduration / $duration_current_master_event)*$beatduration_in_memory)
		$date_end_Xfade_in_memory := $date_end_segment_in_memory + $Xfadeduration_in_memory
		
		$voice := $activevoice							

		ControlRendering $renderer $VoiceName beatScrubPos $voice (-1) $speedratio
		
		;;printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, SENT TO PLAYER:" $voice "JUST change speed:" $speedratio  "nextbeatat?" (($NOW*1000)+$duration_current_master_event)
		;For video applications
		;idx-in-memory-ratio $VoiceName $idx_start_play_in_memory_local $date_start_segment_in_memory $speedratio

		if (!$pulsed && $TimeMaster)
		{ 
			$delay_trigger_next_event := $duration_current_master_event
			$next_event := (($position + 1) % $length_scenario)
			if ($printimproinfo) 
			{
				printAnte $renderer global "(((USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION  AT" ($delay_trigger_next_event+($NOW*1000)) "NOW POSITION = " $position
			}
			($delay_trigger_next_event)ms $signal_new_position := $next_event
			$nb_renderer := $nb_renderer - 1
			if ($printimproinfo) 
			{
				printAnte $renderer global "[[[USR" $VoiceName " *" $pos_process_USR "* " $date_process_USR "]]]" ($NOW*1000) "SIGNALS NEW POSITION AFTER US = " $next_event
			}
			
		}				
}

@proc_def ::StopRendering($VoiceName, $TimeMaster, $pulsed, $position, $activevoice, $time_shift) 
{
		@local $voice
		@local $date_process_StopR, $pos_process_StopR
		@local $delay_trigger_next_event
		@local $next_event
		$date_process_StopR := ($NOW*1000)
		$pos_process_StopR := $position
		
		$voice := $activevoice							
		ControlRendering $renderer $VoiceName beatScrubPos $voice (-1) 0 

		if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName "[StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR "]" ($NOW*1000)
				printAnte $renderer $VoiceName $VoiceName "AT " ($NOW*1000)  "ms, STOPPED VOICEplayer:" $voice "(speed:" 0  ") nextbeatat?" (($NOW*1000)+$duration_current_master_event)
			}

		if (!$pulsed && $TimeMaster)
		{ 
			$delay_trigger_next_event := $duration_current_master_event+$time_shift
			$next_event := (($position + 1) % $length_scenario)
			if ($printimproinfo) 
			{
				printAnte $renderer $VoiceName "(((StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR ")))" ($NOW*1000) "WILL SIGNAL NEW POSITION  AT" ($delay_trigger_next_event+($NOW*1000)) "POSITION NOW =" $signal_new_position $position
			}
			($delay_trigger_next_event)ms $signal_new_position := $next_event
			if ($printimproinfo) 
			{
				printAnte $renderer global "[[[StopR" $VoiceName " *" $pos_process_StopR "* " $date_process_StopR "]]]" ($NOW*1000) "SIGNALS NEW POSITION AFTER STOP_R = " $signal_new_position $next_event
			}
		}
		else { $nb_renderer := $nb_renderer - 1 }							
}


;==================================================================================================================
;==================================================================================================================
; BLOC 3.2: DEFINITION OF THE GENERIC "VOICE" PROCESS
;==================================================================================================================
;==================================================================================================================
$pos_in_impro := -1

whenever W2 ($pos_in_scenario == $pos_in_scenario)
{
	;TODO: CHANGER POUR MODULARISER whenever (new_date_seg_buf)
	if (!$pulsed) 
	{
		if ($first == 1 || $pos_in_scenario == 0)
		{
			$pos_in_impro := $pos_in_scenario 
		} 
		else 
		{
			$pos_in_impro := $pos_in_impro + 1
		}
		$first := 0
		;idx-in-scenario-learning $renderer $pos_in_impro $pos_in_scenario $new_date_seg_buff
		pos_in_impro $renderer $pos_in_impro 
	}
}



$record_setvoice := []


@obj_def Voice($VoiceName, $SequenceImproOfVoice, $MemoryOfVoice, $TimeMaster, $delay = $audio_latency_online)
{
	@local $activevoice := 1, $inactivevoice := 2

	@local $play_pos := -1 ;0
	@local $transpo := 0
	@local $last_event_played := 0
	@local $next_event_anticipated := 0
	@local $start_rendering_launched_at_last_event := 0
	@local $old_idx_in_memory := -1
	@local $old_transpo := -1

	@local $date_W7 := -1.

	@local $start_Xfade := 0
	
	@local $LoopBeat :=0
	@local $iteration_loop := 0
	@local $iteration_W7 := 0

	@local $listened_variable

	@local $impro_segment
	@local $idx_to_play_in_memory
	@local $next_impro_segment, $next_idx_to_play_in_memory, $next_transpo

	@local $modif_anticipations := false

	@local $synctempo
	@init {
		;@local $sync_variable := -1
		;@tempovar $sync_variable(120, 1)
		@local $sync_variable
		@tempovar $sync_variable(120, 1) := -1

		ControlRendering $renderer $VoiceName output_audio 0
	}


	@react ($MemoryOfVoice && $printimproinfo)
	{
		printAnte $renderer $VoiceName "°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°MODIF MEMORY OF VOICE !!!°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°"
		;forall $k, $v in $MemoryOfVoice 
		;{
		;	printAnte $renderer $VoiceName "MEMORYOFVOICE" $k $v
		;}
	}

	@react ($sync_variable == $sync_variable && $sync_variable > -1 && $printimproinfo)
	{ printAnte $renderer $VoiceName "(main" $VoiceName ")" ($NOW*1000) "new sync_variable = " $sync_variable }

	@whenever ($synctempo == $synctempo) { let $sync_variable.tempo := $synctempo }

	@react ($start_Xfade == 1)
	{
		@local $aux := $activevoice 

		ControlRendering $renderer $VoiceName disc $activevoice 0.0
		ControlRendering $renderer $VoiceName disc $inactivevoice 1.0

		$activevoice := $inactivevoice
		$inactivevoice := $aux
	}


	// W7
	@whenever ($listened_variable == $listened_variable)
	{
		$iteration_W7 += 1
		$date_W7 := ($NOW*1000)

		if ($TimeMaster)
		{ _ := .master_update_time() }
		else
		{ _ := .slave_update_time() }

		if ($pulsed)
		{
			if ($iteration_W7 > $iteration_loop)
			{ _ := .handle_next_pulsed_step() }
		}
		else
		{ _ := .handle_next_unpulsed_step() }
	}

	@fun_def slave_update_time()
	{
		;TODO
		; $sync_variable := $listened_variable
		0
	}

	@fun_def master_update_time()
	{
		if ($printimproinfo) 
		{
			printAnte $renderer global "(list_var" $VoiceName $date_W7 ")" "TIME MASTER VOICE" $VoiceName ": RECEIVED LISTENED VAR = " $listened_variable "(signal_new_position)--> SENDS NEW POS_IN_SCENARIO"
		}
		$pos_in_scenario := $listened_variable
		; DONC IL FAUT  QUE LA SYNC VARIABLE D'UNE VOIX MASTER SOIT POS IN SCENARIO SINON N'EST PAS UPDATE ICI !!
		if ($printimproinfo) 
		{
			printAnte $renderer global "(list_var" $VoiceName $date_W7 ")" "pos_in_scenario_by_sequencer = $pos_in_scenario sent to receiver max =" $pos_in_scenario
		}
		pos_in_scenario_by_sequencer $renderer $pos_in_scenario
	}

	@fun_def handle_next_unpulsed_step() { $play_pos := $pos_in_scenario }
	
	@proc_def handle_next_pulsed_step() @exclusive
	{
		@local $first_iteration := true
		@local $idloop := $RNOW
		@local $date_process_L := ($NOW*1000)

		loop 1
		@sync $sync_variable
		@target[3s] @conservative
		@abort {}; printAnte $renderer $VoiceName $VoiceName "!!!!!!!!!!!!!!! ABORT LOOP " $idloop }
		{
			$iteration_loop += 1
						
			if ($first_iteration)
			{
				$first_iteration := false
				$play_pos := $sync_variable
				
				if ($printimproinfo) {
					printAnte $renderer $VoiceName "(list_var / loop" $date_W7 "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "AT " ($NOW*1000) $pos_in_scenario "PLAY POS FIRST ITERATION LOOP"
					printAnte $renderer $VoiceName "(list_var / loop" $date_W7 "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ":" "TEMPO sync_variable" ($sync_variable.tempo) " (associated duration:" (60000/($sync_variable.tempo)) " ms)"
				}

			}
			else
			{
				$play_pos := (($play_pos + 1) % $length_scenario)

				if ($printimproinfo) {
				   printAnte $renderer $VoiceName "(list_var / loop" $date_W7 "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "AT " ($NOW*1000) (($play_pos + 1) % $length_scenario) "PLAY POS UPDATED BY LOOP"
				   printAnte $renderer $VoiceName "(list_var / loop" $date_W7 "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "TEMPO sync_variable" ($sync_variable.tempo) " (associated duration:" (60000/($sync_variable.tempo)) " ms)"
				   printAnte $renderer $VoiceName "(list_var / loop" $date_W7 "/" $date_process_L  $VoiceName ")" "SYNC WHENEVER" "Loop " $idloop ": " "Count loop / whenever :" $relative_count_loop_whenever 
				}		
			}
		}
	}

	;PB: SI ON GENERE LOIN DU TEMPS DE RENDU, SAUTE QUAND MEME.
	@react ($modif_anticipations && ($play_pos > 0))
	{
		printAnte $renderer $VoiceName "***********************MODIF IMPRO SEQUENCE !" 
		printAnte $renderer $VoiceName "***********************MODIF IMPRO SEQUENCE !"
		printAnte $renderer $VoiceName "***********************MODIF IMPRO SEQUENCE !"
		printAnte $renderer $VoiceName "***********************MODIF IMPRO SEQUENCE !"
		printAnte $renderer $VoiceName "***********************MODIF IMPRO SEQUENCE !" $NOW
		
		$next_event_anticipated := 0
		$impro_segment := $SequenceImproOfVoice($play_pos)
		$idx_to_play_in_memory := $impro_segment[0]
		$transpo := $impro_segment[1]

		; Retrieve the data to play at next position
		$next_impro_segment := $SequenceImproOfVoice(($play_pos+1) % $length_scenario) 
		$next_idx_to_play_in_memory := $next_impro_segment[0]
		$next_transpo := $next_impro_segment[1]

		; Update for next time
		$old_idx_in_memory := $idx_to_play_in_memory
		$old_transpo := $transpo
		$modif_anticipations := false
	}

	@react ($play_pos == $play_pos); @exclusive
	{
		@local $date_process := ($NOW*1000)
		@local $pos_process := $play_pos

		
		if ($printimproinfo) {
			printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "$pos_in_impro :" $pos_in_impro "/ $play_pos = " $play_pos ", $sync_variable = " $sync_variable ", tempo = " ($sync_variable.tempo) 
		}

		.handle_current_event()
		.handle_next_event()
	}


	@fun_def handle_current_event()
	{
		@local $jump_now
		@local $start_segment_in_memory, $end_segment_in_memory 
		@local $date_start_segment_in_memory, $date_end_segment_in_memory
		@local $testDEF, $testDEFdates

		; Retrieve the data to play at this position
		$impro_segment := $SequenceImproOfVoice($play_pos)
		$idx_to_play_in_memory := $impro_segment[0]
		$transpo := $impro_segment[1]

		; Update for next time
		$old_idx_in_memory := $idx_to_play_in_memory
		$old_transpo := $transpo

		if ($printimproinfo) {
			printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "$impro_segment :" $impro_segment "$next_impro_segment :" $next_impro_segment
		}

		if (@is_undef($idx_to_play_in_memory)) ;;; IMPOSSIBLE TO PLAY CURRENT EVENT
		{	
			if ($printimproinfo) {
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NOTHING NOW : Index to play in memory undefined"
			}
			$start_Xfade := 1
			::StopRendering($VoiceName, $TimeMaster, $pulsed, $play_pos, $activevoice, 0)
			($Xfadeduration/2) ControlRendering $renderer $VoiceName output_audio 0
			$last_event_played := 0
		}
		else ;;; CURRENT EVENT IS DEFINED
		{
			idx_in_memory $VoiceName $idx_to_play_in_memory
			$jump_now := ($first || !$last_event_played || !$next_event_anticipated)
			if ($printimproinfo) {
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "JUMP NOW: " $jump_now "<-- $first :" $first "!$last_event_played" (!$last_event_played) "!$next_event_anticipated" (!$next_event_anticipated)
			}
			$start_segment_in_memory := $MemoryOfVoice($idx_to_play_in_memory)
			$end_segment_in_memory := $MemoryOfVoice($idx_to_play_in_memory + 1)

			$testDEF := (!(@is_undef($start_segment_in_memory)) && !(@is_undef($end_segment_in_memory)))
			$testDEFdates := $testDEF && (!(@is_undef($start_segment_in_memory[0])) && !(@is_undef($end_segment_in_memory[0])))
			if ($testDEFdates)
			{
				$date_start_segment_in_memory := $start_segment_in_memory[0]
				$date_end_segment_in_memory := $end_segment_in_memory[0] - 1
			}

			if ($jump_now) 
			{ .handle_current_event_discontinuous($testDEFdates) }
			else 
			{ .handle_current_event_continuous($testDEFdates) }
		}
	}
	
	@fun_def handle_current_event_discontinuous($testDEFdates)
	{
		if (!$testDEFdates)	
		{
			::StopRendering($VoiceName, $TimeMaster, $pulsed, $play_pos, $activevoice, 0)
			ControlRendering $renderer $VoiceName output_audio 0
			$last_event_played := 0

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NOTHING NOW (undefined) [LAUNCH StopR *" $pos_process "*]"
			}
		} 
		else 
		{
			$start_Xfade := 1
			::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, $play_pos, ($sync_variable.tempo), $activevoice, $delay, 0)
			$last_event_played := 1		

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" ($NOW*1000) "XFADE NOW & [LAUNCH SR *" $pos_process "*] dates = " $date_start_segment_in_memory $date_end_segment_in_memory
			}
		}
	}

	@fun_def handle_current_event_continuous($testDEFdates) 
	{		
		if ($start_rendering_launched_at_last_event == 1)
		{
			$last_event_played := 1

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "CONTINUOUS NOW AND ANTICIPATED [nothing] "
			}
		}
		else
		{
			if (!$testDEFdates)	
			{
				::StopRendering($VoiceName, $TimeMaster, $pulsed, $play_pos, $activevoice, 0)
				ControlRendering $renderer $VoiceName output_audio 0
				$last_event_played := 0

				if ($printimproinfo) {
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NOTHING NOW (undefined) [LAUNCH StopR *" $pos_process "*]"
				}
			} 
			else 
			{
				::UpdateSpeedRendering($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $play_pos, ($sync_variable.tempo), $activevoice)
				$last_event_played := 1

				if ($printimproinfo) {
					printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "CONTINUOUS NOW [LAUNCH USR *" $pos_process "*] dates = " $date_start_segment_in_memory $date_end_segment_in_memory
				}
			}
		}
	}

	@proc_def handle_next_event()
	{
		@local $jump_at_next_pos
		@local $start_segment_in_memory, $end_segment_in_memory 
		@local $date_start_segment_in_memory, $date_end_segment_in_memory
		@local $testDEF, $testDEFdates

		; Retrieve the data to play at next position
		$next_impro_segment := $SequenceImproOfVoice(($play_pos+1) % $length_scenario) ;TODO MODULO POUR RETOURNER AU DEBUT
		$next_idx_to_play_in_memory := $next_impro_segment[0]
		$next_transpo := $next_impro_segment[1]

		if (@is_undef($next_idx_to_play_in_memory)) ;;; NEXT EVENT : UNKNOWN
		{	
			$next_event_anticipated := 0
			$start_rendering_launched_at_last_event := 0
		}
		else ;;; NEXT EVENT IS DEFINED
		{
			$jump_at_next_pos := (@is_undef($idx_to_play_in_memory) || $idx_to_play_in_memory != ($next_idx_to_play_in_memory -1) || $transpo != $next_transpo)
			$start_segment_in_memory := $MemoryOfVoice($next_idx_to_play_in_memory)
			$end_segment_in_memory := $MemoryOfVoice($next_idx_to_play_in_memory + 1)

			$testDEF := (!(@is_undef($start_segment_in_memory)) && !(@is_undef($end_segment_in_memory)))
			$testDEFdates := $testDEF && (!(@is_undef($start_segment_in_memory[0])) && !(@is_undef($end_segment_in_memory[0])))

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "CURRENT AND NEXT EVENT DEFINED $next_idx_to_play_in_memory :" $next_idx_to_play_in_memory
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "$next_idx_to_play_in_memory :" $next_idx_to_play_in_memory "$next_impro_segment :" $next_impro_segment
				printAnte $renderer $VoiceName $VoiceName "PLAY WHEN. NEXT:"  "JUMP AT NEXT POSITION: " $jump_at_next_pos "<-- NOW IDX UNDEF / NEXT DEF :" (@is_undef($idx_to_play_in_memory)) " NON CONSECUTIVE :" ($idx_to_play_in_memory != ($next_idx_to_play_in_memory -1)) "TRANSPO CHANGE:" ($transpo != $next_transpo) 
			}

			if ($testDEFdates)
			{
				$date_start_segment_in_memory := $start_segment_in_memory[0]
				$date_end_segment_in_memory := $end_segment_in_memory[0] - 1
			}
			$transpo := $next_transpo

			if($jump_at_next_pos) ;;; DISCONTINUITY HANDLED AT NEXT EVENT
			{ _ := .handle_next_event_discontinuous($testDEFdates) }
			else ;;; CONTINUOUS AT NEXT EVENT
			{
				$next_event_anticipated := 1
				$start_rendering_launched_at_last_event := 0

				if ($printimproinfo) {
					printAnte $renderer $VoiceName "CONTINUOUS AT NEXT EVENT" 
					;printAnte $renderer $VoiceName "CONTINUOUS AT NEXT EVENT $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
					;printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" "NEXT EVENT CONTINUOUS dates: (beg $start_segment" $start_segment_in_memory " =)"  $date_start_segment_in_memory "(beg $end_segment" $end_segment_in_memory " -1 =)" $date_end_segment_in_memory
				}
			}
		};end "else @is_undef($next_idx_to_play_in_memory)"
	}	

	@proc_def handle_next_event_discontinuous($testDEFdates) 
	{
		if ($printimproinfo) {
			printAnte $renderer $VoiceName "DISCONTINUITY HANDLED AT NEXT EVENT "
		}

		if (!$testDEFdates)	
		{
			$next_event_anticipated := 0
			$start_rendering_launched_at_last_event := 0

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "DATES NEXT SEGMENT NOT DEF $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")"  "FINALLY NOTHING FOR NEXT EVENT : Segment in the memory at this index is undefined"
			}
		} 
		else 
		{
			$next_event_anticipated := 1
			$start_rendering_launched_at_last_event := 1

			if ($printimproinfo) {
				printAnte $renderer $VoiceName "DATES NEXT SEGMENT DEF $start_segment_in_memory = " $start_segment_in_memory "$end_segment_in_memory =" $end_segment_in_memory
				printAnte $renderer $VoiceName "(play_pos" " *" $pos_process "* " $date_process $VoiceName ")" ($NOW*1000) "(next) WILL XFADE & [WILL LAUNCH SR *" ($pos_process+1) "*] at " (($NOW*1000) + ($duration_current_master_event - ($Xfadeduration/2))) "/ dates = " $date_start_segment_in_memory $date_end_segment_in_memory
			}

			($duration_current_master_event - ($Xfadeduration/2))ms  {
				$start_Xfade := 1
				::StartRenderEvent($VoiceName, $TimeMaster, $pulsed, $date_start_segment_in_memory, $date_end_segment_in_memory, $transpo, ($pos_process + 1), ($sync_variable.tempo), $activevoice, $delay, ($Xfadeduration/2))		
			}
		}
	}
	
} // fin obj





;==================================================================================================================
;==================================================================================================================
; BLOC 4: HANDLING START / STOP IMPRO
; INITIALISATION OF THE VOICES
;==================================================================================================================
;==================================================================================================================


// ------ Voice1

let $currentVoice1 := <undef>

;Synchronizing Voice 1 with the temporal variable "$pos_in_scenario"
whenever W11 ($currentVoice1 && $signal_new_position == $signal_new_position)
{
	if ($printimproinfo)
	{
		printAnte $renderer global "(main/signal_new_pos)" ($NOW*1000) "Voice1 --> LISTENED_VARIABLE (sig...)=" $signal_new_position
	}
	$currentVoice1.$listened_variable := $signal_new_position
}

whenever W12 ($currentVoice1 && $pos_in_scenario == $pos_in_scenario )
{
	$currentVoice1.$sync_variable := $pos_in_scenario
}

whenever W13 ($currentVoice1 && $tempovar_pos_in_scenario)
{
	let $currentVoice1.$synctempo := $tempovar_pos_in_scenario
}	



// ------ Voice2

let $currentVoice2 := <undef>

;;Synchronizing Voice 2 with the temporal variable "$pos_to_play"
whenever W14 ($currentVoice2 && $pos_in_scenario == $pos_in_scenario)
{
	$currentVoice2.$listened_variable := $pos_in_scenario
}
whenever W15 ($currentVoice2 && $pos_to_play == $pos_to_play)
{
	$currentVoice2.$sync_variable := $pos_to_play
}
whenever W16 ($currentVoice2 && $tempovar_pos_to_play)
{
	let $currentVoice2.$synctempo := $tempovar_pos_to_play
}



// ------ Voice3

let $currentVoice3 := <undef>

;;Synchronizing Voice 3 with the temporal variable "$pos_to_play"
whenever W17 ($currentVoice3 && $pos_in_scenario == $pos_in_scenario)
{
	$currentVoice3.$listened_variable := $pos_in_scenario
}
whenever W18 ($currentVoice3 && $pos_to_play == $pos_to_play)
{
	$currentVoice3.$sync_variable := $pos_to_play
}
whenever W19 ($currentVoice3 && $tempovar_pos_to_play)
{
	let $currentVoice3.$synctempo := $tempovar_pos_to_play
}




// ------ Voice4

let $currentVoice4 := <undef>

;;Synchronizing Voice 4 with the temporal variable "$pos_to_play"
whenever W20 ($currentVoice4 && $pos_in_scenario == $pos_in_scenario)
{
	$currentVoice4.$listened_variable := $pos_in_scenario
}
whenever W21 ($currentVoice4 && $pos_to_play == $pos_to_play)
{
	$currentVoice4.$sync_variable := $pos_to_play
}
whenever W22 ($currentVoice4 && $tempovar_pos_to_play)
{
	let $currentVoice4.$synctempo := $tempovar_pos_to_play
}




whenever ($play == 1) ; @exclusive
{ 
	@local $cpt

	if (true || $printimproinfo)
	{
		printAnte $renderer global "_________PLAY : ON_________"
	}

	if ($last_length_scenario !=0) 
	{
		$Scenario := MAP{}
		$SequenceImpro1 := MAP{}
		$SequenceImpro2 := MAP{}
		$SequenceImpro3 := MAP{} 
		$SequenceImpro4 := MAP{}

		$cpt := 0
		loop BuildSequences 0
		{
			; Default "impro"
			$SequenceImpro1 := @add_pair($SequenceImpro1,$cpt, tab[($cpt - 4),0])
			$SequenceImpro2 := @add_pair($SequenceImpro2,$cpt, tab[($cpt - 4),0])
			$SequenceImpro3 := @add_pair($SequenceImpro3,$cpt, tab[($cpt - 4),0])
			$SequenceImpro4 := @add_pair($SequenceImpro4,$cpt, tab[($cpt - 4),0])
			; Default scenario
			$Scenario := @add_pair($Scenario,$cpt, "label")

			$cpt := $cpt + 1
		} until ( $cpt >= $last_length_scenario)

		if ($printimproinfo) 
			{
				printAnte $renderer global "______Default sequences built again______"
				printAnte $renderer global "$Scenario :" $Scenario 
				printAnte $renderer global "$SequenceImpro :" $SequenceImpro
			}
	}

	abort ::SetVoice

	printAnte 1 play 1
	$name_currentVoice1 := "Voice" + $renderer
	$currentVoice1 := ::SetVoice($name_currentVoice1, $SequenceImpro1, $memory1, 1)
	$currentVoice1.$delay := $audio_latency_online

	printAnte 1 play 2
	$num_currentVoice2 := $renderer+1
	$name_currentVoice2 := "Voice" + $num_currentVoice2
	$currentVoice2 := ::SetVoice($name_currentVoice2, $SequenceImpro2, $memory2, 0)
	$currentVoice2.$delay := $audio_latency_online

	printAnte 1 play 3
	$num_currentVoice3 := $renderer+2
	$name_currentVoice3 := "Voice" + $num_currentVoice3
	$currentVoice3 := ::SetVoice($name_currentVoice3, $SequenceImpro3, $memory3, 0)
	$currentVoice3.$delay := $audio_latency_online

	printAnte 1 play 4
	$num_currentVoice4 := $renderer+3
	$name_currentVoice4 := "Voice" + $num_currentVoice4
	$currentVoice4 := ::SetVoice($name_currentVoice4, $SequenceImpro4, $memory4, 0)
	$currentVoice4.$delay := $audio_latency_online

	if ($printimproinfo) 
	{
		printAnte $renderer global "______Processes launched______"
		printAnte $renderer global "$Scenario :" $Scenario 
		printAnte $renderer global "$SequenceImpro :" $SequenceImpro
	}
}

whenever W23 ($play == 0) ; @exclusive
{ 

	if (true || $printimproinfo) 
	{
		printAnte $renderer global "_________PLAY : OFF_________"
	}

	ControlRendering $renderer $name_currentVoice1 output_audio 0
	ControlRendering $renderer $name_currentVoice2 output_audio 0
	ControlRendering $renderer $name_currentVoice3 output_audio 0
	ControlRendering $renderer $name_currentVoice4 output_audio 0

	abort ::SetVoice
	
	/*
	abort $currentVoice1
	abort $currentVoice2
	abort $currentVoice3
	abort $currentVoice4
	*/
	
	if ($printimproinfo) 
	{
		printAnte $renderer global "______Processes aborted______"
	}

}

$date_beginning_buffer := -1
whenever W24 ($startrecordbuffer)
{
	$date_beginning_buffer := $NOW

}

;------------------------------------------------------------------
; ONLINE SEGMENTATION OF THE INPUTS (AUDIO OR NOT...)
;----------------------
; segmented_memory  
; key -> data :
; position in impro -> [date in the buffer, label, position in the scenario]
;----------------------
$first := 1
$new_date_seg_buff := -1
$pos_in_scenario := -1
$pos_to_play := 0
;---

whenever W25 ($new_posinscenario_datesegbuff)
{
	if ($pulsed)
	{
		if ($date_beginning_buffer > -1) {
			$new_date_seg_buff := ($NOW - $date_beginning_buffer)*1000
		} else {
			$new_date_seg_buff := -1
		}

		$new_pos_in_scenario := $new_posinscenario_datesegbuff[0]
		
		if ($printimproinfo) 
		{
			printAnte $renderer Voice1 "\n\n\n"
			printAnte $renderer Voice1 "\n\n\n"
			printAnte $renderer global Voice1 " --------- NEW POS SIGNALED BY BANG" $new_pos_in_scenario " ---------" ($NOW*1000)
			printAnte $renderer global " --------- NEW POS SIGNALED LAUNCHED BY BANG" $new_pos_in_scenario " ---------" ($NOW*1000) 
		}

		if ($first == 1) {
			$pos_in_impro := $new_pos_in_scenario 
			abs_rec_start $new_date_seg_buff ; gn 160607
		} else {
			$pos_in_impro := $pos_in_impro + 1
		}

		$signal_new_position := $new_pos_in_scenario
		if ($printimproinfo) 
		{
			printAnte $renderer global "datesegbuff --> pos_in_scenario_by_sequencer = $signal_new_position sent to receiver max =" $signal_new_position
		}
		pos_in_scenario_by_sequencer $renderer $signal_new_position
		idx-in-scenario-learning $renderer $signal_new_position

		$first := 0
		idx-in-scenario-learning $renderer $pos_in_impro $pos_in_scenario $new_date_seg_buff
		pos_in_impro $renderer $pos_in_impro 

		;Convention : tab [posinscenario, datesegbuff], 
		;with datesegbuff = -1 when offline (no online buffer to segment)
		if ($new_date_seg_buff > -1) 
		{
			$label_new_pos := $Scenario($new_pos_in_scenario)
			$new_segment := tab[$new_date_seg_buff, $label_new_pos, $new_pos_in_scenario]
			$online_memory := @add_pair($online_memory,$pos_in_impro,$new_segment)
			
			if ($printimproinfo) 
			{
				printAnte $renderer global "RECORDING SEGMENT [" $new_segment "]  POUR POS_IN_IMPRO " $pos_in_impro
			}	
		}
	}
}

;==================================================================================================================
;==================================================================================================================
; BLOC 5: HANDLING MEMORY (LOAD AND SAVE)
;==================================================================================================================
;==================================================================================================================
@proc_def SendMap($m, $slot, $idxInTab)
{
	$i := 0
	$s := ""
	forall $k, $v in $m 
	{	
		if ($idxInTab > -1) 
		{
			if ($idxInTab == 1) 
			{
				$s:= $s+(" "+"\""+($v[$idxInTab])+"\"")
			} 
			else 
			{
				$s:= $s+(" "+($v[$idxInTab]))
			}
		} 
		else 
		{
			$s:= $s+(" "+($v))
		}
	
		AnteToSave $renderer (""+$slot) $s
	}
}

whenever W26 ($save_annotations)
{
	::SendMap($online_memory,"labels",1)
	::SendMap($online_memory,"dates",0)
	::SendMap($online_memory,"pos_in_scenario",2)	
	AnteToSave $renderer "last_temposession" $tempovar_pos_to_play
	$play := 0
}

;LOAD MEMORY 1
;==================================================================================================================
$cpt_load_memory_Voice1 := 0
whenever ($cpt_load_memory_Voice1 == $cpt_load_memory_Voice1 && $printimproinfo)
{
	printAnte $renderer $name_currentVoice1 "........... $cpt_load_memory_Voice1 = ........... " $cpt_load_memory_Voice1
	printAnte $renderer $name_currentVoice1 " "
}


$start_pos_load_Voice1 := 0
whenever ($start_pos_load_Voice1 == $start_pos_load_Voice1)
{
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $start_pos_load_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	}
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "LOADED $start_pos_load Voice1" $start_pos_load_Voice1
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $start_pos_load_Voice1 //////////////////// " $cpt_load_memory_Voice1	
	}
}

$load_pos_in_scenario_Voice1 := tab[]
whenever ($load_pos_in_scenario_Voice1)
{
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_pos_in_scenario_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	}
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "LOADED $load_pos_in_scenario Voice1" 
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_pos_in_scenario_Voice1 //////////////////// " $cpt_load_memory_Voice1
	}
}

$load_labels_Voice1 := tab[]
whenever ($load_labels_Voice1)
{
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_labels_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	}
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1  "LOADED $load_labels Voice1"
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_labels_Voice1 //////////////////// " $cpt_load_memory_Voice1
	}
}

$load_dates_Voice1 := tab[]
whenever ($load_dates_Voice1)
{
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_dates_Voice1 BEFORE //////////////////// " $cpt_load_memory_Voice1
	}
	$cpt_load_memory_Voice1 := $cpt_load_memory_Voice1 + 1
	if ($printimproinfo) 
	{
		printAnte $renderer $name_currentVoice1  "LOADED $load_dates Voice1"
		printAnte $renderer $name_currentVoice1 "//////////////////// $cpt_load_memory_Voice1 $load_dates_Voice1 //////////////////// " $cpt_load_memory_Voice1
	}
}

whenever ($cpt_load_memory_Voice1 == 4)
{
	@local $posi, $p, $k, $v
	
	$loaded_memory_Voice1 := MAP{}
	$currentVoice1.$delay := $audio_latency_offline
	$posi := $start_pos_load_Voice1
	forall $p in $load_pos_in_scenario_Voice1
	{
		$loaded_memory_segment_Voice1 := tab[($load_dates_Voice1[($posi - $start_pos_load_Voice1)]), ($load_labels_Voice1[($posi - $start_pos_load_Voice1)]), $p]
		$currentVoice1.$MemoryOfVoice := @add_pair($currentVoice1.$MemoryOfVoice,$posi,$loaded_memory_segment_Voice1)
		$posi := $posi + 1
	}
	$cpt_load_memory_Voice1 := 0

	if ($printimproinfo) 
	{
		printAnte $renderer Voice1 "*****MEMORY Voice1 LOADED*****" ($currentVoice1.$MemoryOfVoice)
	}
}


;LOAD MEMORY 2
;==================================================================================================================
$cpt_load_memory_Voice2 := 0

whenever ($cpt_load_memory_Voice2)
{
	;printAnte $renderer Voice2 "!!!!!!!!!!!!!!!!!!!!!! $cpt_load_memory_Voice2 !!!!!!!!!!!!!!!!!!!!!! " $cpt_load_memory_Voice2
}


$start_pos_load_Voice2 := 0
whenever ($start_pos_load_Voice2 == $start_pos_load_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
}

$load_pos_in_scenario_Voice2 := tab[]
whenever ($load_pos_in_scenario_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
}

$load_labels_Voice2 := tab[]
whenever ($load_labels_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
}

$load_dates_Voice2 := tab[]
whenever ($load_dates_Voice2)
{
	$cpt_load_memory_Voice2 := $cpt_load_memory_Voice2 + 1
}

whenever ($cpt_load_memory_Voice2 == 4)
{
	@local $posi, $p, $k, $v
	
	$loaded_memory_Voice2 := MAP{}
	$currentVoice2.$delay := $audio_latency_offline
	$posi := $start_pos_load_Voice2

	;printAnte $renderer Voice2 "***** $start_pos_load_Voice2 *****" $start_pos_load_Voice2

	forall $p in $load_pos_in_scenario_Voice2
	{
		$loaded_memory_segment_Voice2 := tab[($load_dates_Voice2[($posi - $start_pos_load_Voice2)]), ($load_labels_Voice2[($posi - $start_pos_load_Voice2)]), $p]
		$currentVoice2.$MemoryOfVoice := @add_pair($currentVoice2.$MemoryOfVoice,$posi,$loaded_memory_segment_Voice2)
		$posi := $posi + 1
	}

	$cpt_load_memory_Voice2 := 0
	;printAnte $renderer Voice2 "*****MEMORY Voice2 LOADED*****" ($currentVoice2.$MemoryOfVoice)
}

;LOAD MEMORY 3
;==================================================================================================================
$cpt_load_memory_Voice3 := 0

whenever ($cpt_load_memory_Voice3)
{
	;printAnte $renderer Voice3 "!!!!!!!!!!!!!!!!!!!!!! $cpt_load_memory_Voice3 !!!!!!!!!!!!!!!!!!!!!! " $cpt_load_memory_Voice3
}


$start_pos_load_Voice3 := 0
whenever ($start_pos_load_Voice3 == $start_pos_load_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1	
}

$load_pos_in_scenario_Voice3 := tab[]
whenever ($load_pos_in_scenario_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
}

$load_labels_Voice3 := tab[]
whenever ($load_labels_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
}

$load_dates_Voice3 := tab[]
whenever ($load_dates_Voice3)
{
	$cpt_load_memory_Voice3 := $cpt_load_memory_Voice3 + 1
}

whenever ($cpt_load_memory_Voice3 == 4)
{
	@local $posi, $p, $k, $v
	
	$loaded_memory_Voice3 := MAP{}
	$currentVoice3.$delay := $audio_latency_offline
	$posi := $start_pos_load_Voice3

	;printAnte $renderer Voice3 "***** $start_pos_load_Voice3 *****" $start_pos_load_Voice3

	forall $p in $load_pos_in_scenario_Voice3
	{
		$loaded_memory_segment_Voice3 := tab[($load_dates_Voice3[($posi - $start_pos_load_Voice3)]), ($load_labels_Voice3[($posi - $start_pos_load_Voice3)]), $p]
		$currentVoice3.$MemoryOfVoice := @add_pair($currentVoice3.$MemoryOfVoice,$posi,$loaded_memory_segment_Voice3)
		$posi := $posi + 1
	}
	
	$cpt_load_memory_Voice3 := 0
	;printAnte $renderer Voice3 "*****MEMORY Voice3 LOADED*****" ($currentVoice3.$MemoryOfVoice)

}

;LOAD MEMORY 4
;==================================================================================================================
$cpt_load_memory_Voice4 := 0
whenever ($cpt_load_memory_Voice4)
{
	; printAnte $renderer Voice4 "!!!!!!!!!!!!!!!!!!!!!! $cpt_load_memory_Voice4 !!!!!!!!!!!!!!!!!!!!!! " $cpt_load_memory_Voice4

}

$start_pos_load_Voice4 := 0
whenever ($start_pos_load_Voice4 == $start_pos_load_Voice4)
{
	$cpt_load_memory_Voice4 := $cpt_load_memory_Voice4 + 1
}

$load_pos_in_scenario_Voice4 := tab[]
whenever ($load_pos_in_scenario_Voice4)
{
	$cpt_load_memory_Voice4 := $cpt_load_memory_Voice4 + 1	
}

$load_labels_Voice4 := tab[]
whenever ($load_labels_Voice4)
{
	$cpt_load_memory_Voice4 := $cpt_load_memory_Voice4 + 1
}

$load_dates_Voice4 := tab[]
whenever ($load_dates_Voice4)
{
	$cpt_load_memory_Voice4 := $cpt_load_memory_Voice4 + 1

}

whenever ($cpt_load_memory_Voice4 == 4)
{
	@local $posi, $p, $k, $v
	
	$loaded_memory_Voice4 := MAP{}
	$currentVoice4.$delay := $audio_latency_offline
	$posi := $start_pos_load_Voice4

	;printAnte $renderer Voice4 "***** $start_pos_load_Voice4 *****" $start_pos_load_Voice4

	forall $p in $load_pos_in_scenario_Voice4
	{
		$loaded_memory_segment_Voice4 := tab[($load_dates_Voice4[($posi - $start_pos_load_Voice4)]), ($load_labels_Voice4[($posi - $start_pos_load_Voice4)]), $p]
		$currentVoice4.$MemoryOfVoice := @add_pair($currentVoice4.$MemoryOfVoice,$posi,$loaded_memory_segment_Voice4)
		$posi := $posi + 1
	}

	$cpt_load_memory_Voice4 := 0
	;printAnte $renderer Voice4 "*****MEMORY Voice4 LOADED*****" ($currentVoice4.$MemoryOfVoice)

}

;==================================================================================================================
;==================================================================================================================
; BLOC 6: HANDLING SCENARIOS AND IMPROS (SAVE AND LOAD)
;==================================================================================================================
;==================================================================================================================
whenever ($ModifScenario0)
{
	@local $k, $v
	printAnte $renderer global "PREVIOUS SCENARIO :" $Scenario
	forall $k, $v in $ModifScenario0 {
			$Scenario := @add_pair($Scenario,$k, $v)
	}
	;printAnte $renderer global "NEW SCENARIO :" $Scenario
}

whenever ($ModifSequenceImproOfVoice1)
{
	@local $k, $v
	if ($printimproinfo) 
	{
		printAnte $renderer Voice1 "VOICE 1 : PREVIOUS IMPRO :" $currentVoice1.$SequenceImproOfVoice
	}
	forall $k, $v in $ModifSequenceImproOfVoice1 {
			$currentVoice1.$SequenceImproOfVoice := @add_pair(($currentVoice1.$SequenceImproOfVoice),$k, $v)
	}
	if (true || $printimproinfo) 
	{
		printAnte $renderer Voice1 "VOICE 1 : NEW IMPRO :" $NOW
	}
	$currentVoice1.$modif_anticipations := true
}

whenever ($ModifSequenceImproOfVoice2)
{
	@local $k, $v
	;printAnte $renderer Voice2 "VOICE 2 : PREVIOUS IMPRO :" $currentVoice2.$SequenceImproOfVoice
	forall $k, $v in $ModifSequenceImproOfVoice2 {
			$currentVoice2.$SequenceImproOfVoice := @add_pair(($currentVoice2.$SequenceImproOfVoice),$k, $v)
	}
	printAnte $renderer Voice2 "VOICE 2 : NEW IMPRO :" $currentVoice2.$SequenceImproOfVoice $NOW
	$currentVoice2.$modif_anticipations := true
}

whenever ($ModifSequenceImproOfVoice3)
{
	@local $k, $v
	;printAnte $renderer Voice3 "VOICE 3 : PREVIOUS IMPRO :" $currentVoice3.$SequenceImproOfVoice
	forall $k, $v in $ModifSequenceImproOfVoice3 {
			$currentVoice3.$SequenceImproOfVoice := @add_pair(($currentVoice3.$SequenceImproOfVoice),$k, $v)
	}
	printAnte $renderer Voice3 "VOICE 3 : NEW IMPRO :" $currentVoice3.$SequenceImproOfVoice $NOW
	$currentVoice3.$modif_anticipations := true
}

whenever ($ModifSequenceImproOfVoice4)
{
	@local $k, $v
	;printAnte $renderer Voice4 "VOICE 4 : PREVIOUS IMPRO :" $currentVoice4.$SequenceImproOfVoice
	forall $k, $v in $ModifSequenceImproOfVoice4 {
			$currentVoice4.$SequenceImproOfVoice := @add_pair(($currentVoice4.$SequenceImproOfVoice),$k, $v)
	}
	printAnte $renderer Voice4 "VOICE 4 : NEW IMPRO :" $currentVoice4.$SequenceImproOfVoice $NOW
	$currentVoice4.$modif_anticipations := true
}
